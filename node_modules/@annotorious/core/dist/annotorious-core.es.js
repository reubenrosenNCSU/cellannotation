var M = Object.prototype.hasOwnProperty;
function k(e, t) {
  var n, o;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && k(e[o], t[o]); ) ;
      return o === -1;
    }
    if (!n || typeof e == "object") {
      o = 0;
      for (n in e)
        if (M.call(e, n) && ++o && !M.call(t, n) || !(n in t) || !k(e[n], t[n])) return !1;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
function V() {
}
function X(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
const N = [];
function j(e, t = V) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function s(b) {
    if (X(e, b) && (e = b, n)) {
      const w = !N.length;
      for (const m of o)
        m[1](), N.push(m, e);
      if (w) {
        for (let m = 0; m < N.length; m += 2)
          N[m][0](N[m + 1]);
        N.length = 0;
      }
    }
  }
  function f(b) {
    s(b(e));
  }
  function A(b, w = V) {
    const m = [b, w];
    return o.add(m), o.size === 1 && (n = t(s, f) || V), b(e), () => {
      o.delete(m), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: s, update: f, subscribe: A };
}
const Ue = (e) => {
  const { subscribe: t, set: n } = j();
  let o;
  return t((s) => o = s), e.observe(({ changes: s }) => {
    if (o) {
      (s.deleted || []).some((b) => b.id === o) && n(void 0);
      const A = (s.updated || []).find(({ oldValue: b }) => b.id === o);
      A && n(A.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: t,
    set: n
  };
};
var Z = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(Z || {});
const z = { selected: [] }, Se = (e, t, n) => {
  const { subscribe: o, set: s } = j(z);
  let f = t, A = z;
  o((h) => A = h);
  const b = () => {
    k(A, z) || s(z);
  }, w = () => {
    var h;
    return ((h = A.selected) == null ? void 0 : h.length) === 0;
  }, m = (h) => {
    if (w())
      return !1;
    const C = typeof h == "string" ? h : h.id;
    return A.selected.some((D) => D.id === C);
  }, U = (h, C) => {
    let D;
    if (Array.isArray(h)) {
      if (D = h.map((i) => e.getAnnotation(i)).filter(Boolean), D.length < h.length) {
        console.warn("Invalid selection: " + h.filter((i) => !D.some((p) => p.id === i)));
        return;
      }
    } else {
      const i = e.getAnnotation(h);
      if (!i) {
        console.warn("Invalid selection: " + h);
        return;
      }
      D = [i];
    }
    const a = D.reduce((i, p) => {
      const v = W(p, f, n);
      return v === "EDIT" ? [...i, { id: p.id, editable: !0 }] : v === "SELECT" ? [...i, { id: p.id }] : i;
    }, []);
    s({ selected: a, event: C });
  }, c = (h, C) => {
    const D = Array.isArray(h) ? h : [h], a = D.map((i) => e.getAnnotation(i)).filter((i) => !!i);
    s({
      selected: a.map((i) => {
        const p = C === void 0 ? W(i, f, n) === "EDIT" : C;
        return { id: i.id, editable: p };
      })
    }), a.length !== D.length && console.warn("Invalid selection", h);
  }, E = (h) => {
    if (w())
      return !1;
    const { selected: C } = A;
    C.some(({ id: a }) => h.includes(a)) && s({ selected: C.filter(({ id: a }) => !h.includes(a)) });
  }, T = (h) => {
    f = h, c(A.selected.map(({ id: C }) => C));
  };
  return e.observe(
    ({ changes: h }) => E((h.deleted || []).map((C) => C.id))
  ), {
    get event() {
      return A ? A.event : null;
    },
    get selected() {
      return A ? [...A.selected] : null;
    },
    get userSelectAction() {
      return f;
    },
    clear: b,
    isEmpty: w,
    isSelected: m,
    setSelected: c,
    setUserSelectAction: T,
    subscribe: o,
    userSelect: U
  };
}, W = (e, t, n) => {
  const o = n ? n.serialize(e) : e;
  return typeof t == "function" ? t(o) : t || "EDIT";
}, R = [];
for (let e = 0; e < 256; ++e)
  R.push((e + 256).toString(16).slice(1));
function F(e, t = 0) {
  return (R[e[t + 0]] + R[e[t + 1]] + R[e[t + 2]] + R[e[t + 3]] + "-" + R[e[t + 4]] + R[e[t + 5]] + "-" + R[e[t + 6]] + R[e[t + 7]] + "-" + R[e[t + 8]] + R[e[t + 9]] + "-" + R[e[t + 10]] + R[e[t + 11]] + R[e[t + 12]] + R[e[t + 13]] + R[e[t + 14]] + R[e[t + 15]]).toLowerCase();
}
let _;
const K = new Uint8Array(16);
function ee() {
  if (!_) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    _ = crypto.getRandomValues.bind(crypto);
  }
  return _(K);
}
const te = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), q = { randomUUID: te };
function G(e, t, n) {
  if (q.randomUUID && !t && !e)
    return q.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || ee)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, F(o);
}
const Te = (e) => {
  const { creator: t, updatedBy: n } = e.target, o = e.bodies.reduce((s, f) => [...s, f.creator, f.updatedBy].filter(Boolean), []);
  return [
    t,
    n,
    ...o
  ].filter((s) => s);
}, Y = (e) => {
  const t = (n) => {
    const o = { ...n };
    return n.created && typeof n.created == "string" && (o.created = new Date(n.created)), n.updated && typeof n.updated == "string" && (o.updated = new Date(n.updated)), o;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(t),
    target: t(e.target)
  };
}, De = (e, t, n, o) => ({
  id: G(),
  annotation: typeof e == "string" ? e : e.id,
  created: n || /* @__PURE__ */ new Date(),
  creator: o,
  ...t
}), ne = (e, t) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
}, oe = (e, t) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
}, se = (e, t) => t.bodies.map((n) => {
  const o = e.bodies.find((s) => s.id === n.id);
  return { newBody: n, oldBody: o && !k(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), ie = (e, t) => !k(e.target, t.target), J = (e, t) => {
  const n = ne(e, t), o = oe(e, t), s = se(e, t);
  return {
    oldValue: e,
    newValue: t,
    bodiesCreated: n.length > 0 ? n : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: s.length > 0 ? s : void 0,
    targetUpdated: ie(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0
  };
};
var de = /* @__PURE__ */ ((e) => (e.BODY_ONLY = "BODY_ONLY", e.TARGET_ONLY = "TARGET_ONLY", e))(de || {}), O = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(O || {});
const re = (e, t) => {
  var f, A;
  const { changes: n, origin: o } = t;
  if (!(e.options.origin ? e.options.origin === o : o !== "SILENT"))
    return !1;
  if (e.options.ignore) {
    const { ignore: b } = e.options, w = (U) => U && U.length > 0;
    if (!(w(n.created) || w(n.deleted))) {
      const U = (f = n.updated) == null ? void 0 : f.some((E) => w(E.bodiesCreated) || w(E.bodiesDeleted) || w(E.bodiesUpdated)), c = (A = n.updated) == null ? void 0 : A.some((E) => E.targetUpdated);
      if (b === "BODY_ONLY" && U && !c || b === "TARGET_ONLY" && c && !U)
        return !1;
    }
  }
  if (e.options.annotations) {
    const b = /* @__PURE__ */ new Set([
      ...(n.created || []).map((m) => m.id),
      ...(n.deleted || []).map((m) => m.id),
      ...(n.updated || []).map(({ oldValue: m }) => m.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((m) => b.has(m));
  } else
    return !0;
}, ae = (e, t) => {
  const n = new Set((e.created || []).map((c) => c.id)), o = new Set((e.updated || []).map(({ newValue: c }) => c.id)), s = new Set((t.created || []).map((c) => c.id)), f = new Set((t.deleted || []).map((c) => c.id)), A = new Set((t.updated || []).map(({ oldValue: c }) => c.id)), b = new Set((t.updated || []).filter(({ oldValue: c }) => n.has(c.id) || o.has(c.id)).map(({ oldValue: c }) => c.id)), w = [
    ...(e.created || []).filter((c) => !f.has(c.id)).map((c) => A.has(c.id) ? t.updated.find(({ oldValue: E }) => E.id === c.id).newValue : c),
    ...t.created || []
  ], m = [
    ...(e.deleted || []).filter((c) => !s.has(c.id)),
    ...(t.deleted || []).filter((c) => !n.has(c.id))
  ], U = [
    ...(e.updated || []).filter(({ newValue: c }) => !f.has(c.id)).map((c) => {
      const { oldValue: E, newValue: T } = c;
      if (A.has(T.id)) {
        const h = t.updated.find((C) => C.oldValue.id === T.id).newValue;
        return J(E, h);
      } else
        return c;
    }),
    ...(t.updated || []).filter(({ oldValue: c }) => !b.has(c.id))
  ];
  return { created: w, deleted: m, updated: U };
}, $ = (e) => {
  const t = e.id === void 0 ? G() : e.id;
  return {
    ...e,
    id: t,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((n) => ({
      ...n,
      annotation: t
    })),
    target: {
      ...e.target,
      annotation: t
    }
  };
}, ce = (e) => e.id !== void 0, Oe = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (d, l = {}) => {
    n.push({ onChange: d, options: l });
  }, s = (d) => {
    const l = n.findIndex((u) => u.onChange == d);
    l > -1 && n.splice(l, 1);
  }, f = (d, l) => {
    const u = {
      origin: d,
      changes: {
        created: l.created || [],
        updated: l.updated || [],
        deleted: l.deleted || []
      },
      state: [...e.values()]
    };
    n.forEach((g) => {
      re(g, u) && g.onChange(u);
    });
  }, A = (d, l = O.LOCAL) => {
    if (d.id && e.get(d.id))
      throw Error(`Cannot add annotation ${d.id} - exists already`);
    {
      const g = $(d);
      e.set(g.id, g), g.bodies.forEach((S) => t.set(S.id, g.id)), f(l, { created: [g] });
    }
  }, b = (d, l) => {
    const u = $(typeof d == "string" ? l : d), g = typeof d == "string" ? d : d.id, S = g && e.get(g);
    if (S) {
      const y = J(S, u);
      return g === u.id ? e.set(g, u) : (e.delete(g), e.set(u.id, u)), S.bodies.forEach((x) => t.delete(x.id)), u.bodies.forEach((x) => t.set(x.id, u.id)), y;
    } else
      console.warn(`Cannot update annotation ${g} - does not exist`);
  }, w = (d, l = O.LOCAL, u = O.LOCAL) => {
    const g = ce(l) ? u : l, S = b(d, l);
    S && f(g, { updated: [S] });
  }, m = (d, l = O.LOCAL) => {
    const u = d.reduce((g, S) => {
      const y = b(S);
      return y ? [...g, y] : g;
    }, []);
    u.length > 0 && f(l, { updated: u });
  }, U = (d, l = O.LOCAL) => {
    const u = e.get(d.annotation);
    if (u) {
      const g = {
        ...u,
        bodies: [...u.bodies, d]
      };
      e.set(u.id, g), t.set(d.id, g.id), f(l, { updated: [{
        oldValue: u,
        newValue: g,
        bodiesCreated: [d]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${d.annotation}`);
  }, c = () => [...e.values()], E = (d = O.LOCAL) => {
    const l = [...e.values()];
    e.clear(), t.clear(), f(d, { deleted: l });
  }, T = (d, l = !0, u = O.LOCAL) => {
    const g = d.map($);
    if (l) {
      const S = [...e.values()];
      e.clear(), t.clear(), g.forEach((y) => {
        e.set(y.id, y), y.bodies.forEach((x) => t.set(x.id, y.id));
      }), f(u, { created: g, deleted: S });
    } else {
      const S = d.reduce((y, x) => {
        const H = x.id && e.get(x.id);
        return H ? [...y, H] : y;
      }, []);
      if (S.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${S.map((y) => y.id).join(", ")}`);
      g.forEach((y) => {
        e.set(y.id, y), y.bodies.forEach((x) => t.set(x.id, y.id));
      }), f(u, { created: g });
    }
  }, h = (d) => {
    const l = typeof d == "string" ? d : d.id, u = e.get(l);
    if (u)
      return e.delete(l), u.bodies.forEach((g) => t.delete(g.id)), u;
    console.warn(`Attempt to delete missing annotation: ${l}`);
  }, C = (d, l = O.LOCAL) => {
    const u = h(d);
    u && f(l, { deleted: [u] });
  }, D = (d, l = O.LOCAL) => {
    const u = d.reduce((g, S) => {
      const y = h(S);
      return y ? [...g, y] : g;
    }, []);
    u.length > 0 && f(l, { deleted: u });
  }, a = (d) => {
    const l = e.get(d.annotation);
    if (l) {
      const u = l.bodies.find((g) => g.id === d.id);
      if (u) {
        t.delete(u.id);
        const g = {
          ...l,
          bodies: l.bodies.filter((y) => y.id !== d.id)
        };
        return e.set(l.id, g), {
          oldValue: l,
          newValue: g,
          bodiesDeleted: [u]
        };
      } else
        console.warn(`Attempt to delete missing body ${d.id} from annotation ${d.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${d.annotation}`);
  }, i = (d, l = O.LOCAL) => {
    const u = a(d);
    u && f(l, { updated: [u] });
  }, p = (d, l = O.LOCAL) => {
    const u = d.map((g) => a(g)).filter(Boolean);
    u.length > 0 && f(l, { updated: u });
  }, v = (d) => {
    const l = e.get(d);
    return l ? { ...l } : void 0;
  }, r = (d) => {
    const l = t.get(d);
    if (l) {
      const g = v(l).bodies.find((S) => S.id === d);
      if (g)
        return g;
      console.error(`Store integrity error: body ${d} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${d}`);
  }, L = (d, l) => {
    if (d.annotation !== l.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const u = e.get(d.annotation);
    if (u) {
      const g = u.bodies.find((y) => y.id === d.id), S = {
        ...u,
        bodies: u.bodies.map((y) => y.id === g.id ? l : y)
      };
      return e.set(u.id, S), g.id !== l.id && (t.delete(g.id), t.set(l.id, S.id)), {
        oldValue: u,
        newValue: S,
        bodiesUpdated: [{ oldBody: g, newBody: l }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${d.annotation}`);
  }, B = (d, l, u = O.LOCAL) => {
    const g = L(d, l);
    g && f(u, { updated: [g] });
  }, I = (d, l = O.LOCAL) => {
    const u = d.map((g) => L({ id: g.id, annotation: g.annotation }, g)).filter(Boolean);
    f(l, { updated: u });
  }, P = (d) => {
    const l = e.get(d.annotation);
    if (l) {
      const u = {
        ...l,
        target: {
          ...l.target,
          ...d
        }
      };
      return e.set(l.id, u), {
        oldValue: l,
        newValue: u,
        targetUpdated: {
          oldTarget: l.target,
          newTarget: d
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${d.annotation}`);
  };
  return {
    addAnnotation: A,
    addBody: U,
    all: c,
    bulkAddAnnotation: T,
    bulkDeleteAnnotation: D,
    bulkDeleteBodies: p,
    bulkUpdateAnnotation: m,
    bulkUpdateBodies: I,
    bulkUpdateTargets: (d, l = O.LOCAL) => {
      const u = d.map((g) => P(g)).filter(Boolean);
      u.length > 0 && f(l, { updated: u });
    },
    clear: E,
    deleteAnnotation: C,
    deleteBody: i,
    getAnnotation: v,
    getBody: r,
    observe: o,
    unobserve: s,
    updateAnnotation: w,
    updateBody: B,
    updateTarget: (d, l = O.LOCAL) => {
      const u = P(d);
      u && f(l, { updated: [u] });
    }
  };
}, Re = (e) => ({
  ...e,
  subscribe: (n) => {
    const o = (s) => n(s.state);
    return e.observe(o), n(e.all()), () => e.unobserve(o);
  }
});
let Q = () => ({
  emit(e, ...t) {
    for (let n = this.events[e] || [], o = 0, s = n.length; o < s; o++)
      n[o](...t);
  },
  events: {},
  on(e, t) {
    var n;
    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((s) => t !== s);
    };
  }
});
const le = 250, Be = (e, t) => {
  const n = Q(), o = (t == null ? void 0 : t.changes) || [];
  let s = t ? t.pointer : -1, f = !1, A = 0;
  const b = (r) => {
    if (!f) {
      const { changes: L } = r, B = performance.now();
      if (B - A > le)
        o.splice(s + 1), o.push(L), s = o.length - 1;
      else {
        const I = o.length - 1;
        o[I] = ae(o[I], L);
      }
      A = B;
    }
    f = !1;
  };
  e.observe(b, { origin: O.LOCAL });
  const w = (r) => r && r.length > 0 && e.bulkDeleteAnnotation(r), m = (r) => r && r.length > 0 && e.bulkAddAnnotation(r, !1), U = (r) => r && r.length > 0 && e.bulkUpdateAnnotation(r.map(({ oldValue: L }) => L)), c = (r) => r && r.length > 0 && e.bulkUpdateAnnotation(r.map(({ newValue: L }) => L)), E = (r) => r && r.length > 0 && e.bulkAddAnnotation(r, !1), T = (r) => r && r.length > 0 && e.bulkDeleteAnnotation(r);
  return {
    canRedo: () => o.length - 1 > s,
    canUndo: () => s > -1,
    destroy: () => e.unobserve(b),
    getHistory: () => ({ changes: [...o], pointer: s }),
    on: (r, L) => n.on(r, L),
    redo: () => {
      if (o.length - 1 > s) {
        f = !0;
        const { created: r, updated: L, deleted: B } = o[s + 1];
        m(r), c(L), T(B), n.emit("redo", o[s + 1]), s += 1;
      }
    },
    undo: () => {
      if (s > -1) {
        f = !0;
        const { created: r, updated: L, deleted: B } = o[s];
        w(r), U(L), E(B), n.emit("undo", o[s]), s -= 1;
      }
    }
  };
}, xe = () => {
  const { subscribe: e, set: t } = j([]);
  return {
    subscribe: e,
    set: t
  };
}, Ie = (e, t, n, o) => {
  const { hover: s, selection: f, store: A, viewport: b } = e, w = /* @__PURE__ */ new Map();
  let m = [], U, c;
  const E = (a, i) => {
    w.has(a) ? w.get(a).push(i) : w.set(a, [i]);
  }, T = (a, i) => {
    const p = w.get(a);
    if (p) {
      const v = p.indexOf(i);
      v !== -1 && p.splice(v, 1);
    }
  }, h = (a, i, p) => {
    w.has(a) && setTimeout(() => {
      w.get(a).forEach((v) => {
        if (n) {
          const r = Array.isArray(i) ? i.map((B) => n.serialize(B)) : n.serialize(i), L = p ? p instanceof PointerEvent ? p : n.serialize(p) : void 0;
          v(r, L);
        } else
          v(i, p);
      });
    }, 1);
  }, C = () => {
    const { selected: a } = f, i = (a || []).map(({ id: p }) => A.getAnnotation(p));
    i.forEach((p) => {
      const v = m.find((r) => r.id === p.id);
      (!v || !k(v, p)) && h("updateAnnotation", p, v);
    }), m = m.map((p) => {
      const v = i.find(({ id: r }) => r === p.id);
      return v || p;
    });
  };
  f.subscribe(({ selected: a }) => {
    if (!(m.length === 0 && a.length === 0)) {
      if (m.length === 0 && a.length > 0)
        m = a.map(({ id: i }) => A.getAnnotation(i));
      else if (m.length > 0 && a.length === 0)
        m.forEach((i) => {
          const p = A.getAnnotation(i.id);
          p && !k(p, i) && h("updateAnnotation", p, i);
        }), m = [];
      else {
        const i = new Set(m.map((r) => r.id)), p = new Set(a.map(({ id: r }) => r));
        m.filter((r) => !p.has(r.id)).forEach((r) => {
          const L = A.getAnnotation(r.id);
          L && !k(L, r) && h("updateAnnotation", L, r);
        }), m = [
          // Remove annotations that were deselected
          ...m.filter((r) => p.has(r.id)),
          // Add editable annotations that were selected
          ...a.filter(({ id: r }) => !i.has(r)).map(({ id: r }) => A.getAnnotation(r))
        ];
      }
      h("selectionChanged", m);
    }
  }), s.subscribe((a) => {
    !U && a ? h("mouseEnterAnnotation", A.getAnnotation(a)) : U && !a ? h("mouseLeaveAnnotation", A.getAnnotation(U)) : U && a && (h("mouseLeaveAnnotation", A.getAnnotation(U)), h("mouseEnterAnnotation", A.getAnnotation(a))), U = a;
  }), b == null || b.subscribe((a) => h("viewportIntersect", a.map((i) => A.getAnnotation(i)))), A.observe((a) => {
    o && (c && clearTimeout(c), c = setTimeout(C, 1e3));
    const { created: i, deleted: p } = a.changes;
    (i || []).forEach((r) => h("createAnnotation", r)), (p || []).forEach((r) => h("deleteAnnotation", r)), (a.changes.updated || []).filter((r) => [
      ...r.bodiesCreated || [],
      ...r.bodiesDeleted || [],
      ...r.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: r, newValue: L }) => {
      const B = m.find((I) => I.id === r.id) || r;
      m = m.map((I) => I.id === r.id ? L : I), h("updateAnnotation", L, B);
    });
  }, { origin: O.LOCAL }), A.observe((a) => {
    if (m) {
      const i = new Set(m.map((v) => v.id)), p = (a.changes.updated || []).filter(({ newValue: v }) => i.has(v.id)).map(({ newValue: v }) => v);
      p.length > 0 && (m = m.map((v) => {
        const r = p.find((L) => L.id === v.id);
        return r || v;
      }));
    }
  }, { origin: O.REMOTE });
  const D = (a) => (i) => {
    const { updated: p } = i;
    a ? (p || []).forEach((v) => h("updateAnnotation", v.oldValue, v.newValue)) : (p || []).forEach((v) => h("updateAnnotation", v.newValue, v.oldValue));
  };
  return t.on("undo", D(!0)), t.on("redo", D(!1)), { on: E, off: T, emit: h };
}, ke = (e) => (t) => t.map((n) => e.serialize(n)), ue = (e) => (t) => t.reduce((n, o) => {
  const { parsed: s, error: f } = e.parse(o);
  return f ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : s ? {
    parsed: [...n.parsed, s],
    failed: n.failed
  } : {
    ...n
  };
}, { parsed: [], failed: [] }), Ne = (e, t, n) => {
  const { store: o, selection: s } = e, f = (a) => {
    if (n) {
      const { parsed: i, error: p } = n.parse(a);
      i ? o.addAnnotation(i, O.REMOTE) : console.error(p);
    } else
      o.addAnnotation(Y(a), O.REMOTE);
  }, A = () => s.clear(), b = () => o.clear(), w = (a) => {
    const i = o.getAnnotation(a);
    return n && i ? n.serialize(i) : i;
  }, m = () => n ? o.all().map(n.serialize) : o.all(), U = () => {
    var p;
    const i = (((p = s.selected) == null ? void 0 : p.map((v) => v.id)) || []).map((v) => o.getAnnotation(v)).filter(Boolean);
    return n ? i.map(n.serialize) : i;
  }, c = (a, i = !0) => fetch(a).then((p) => p.json()).then((p) => (T(p, i), p)), E = (a) => {
    if (typeof a == "string") {
      const i = o.getAnnotation(a);
      if (o.deleteAnnotation(a), i)
        return n ? n.serialize(i) : i;
    } else {
      const i = n ? n.parse(a).parsed : a;
      if (i)
        return o.deleteAnnotation(i), a;
    }
  }, T = (a, i = !0) => {
    if (n) {
      const p = n.parseAll || ue(n), { parsed: v, failed: r } = p(a);
      r.length > 0 && console.warn(`Discarded ${r.length} invalid annotations`, r), o.bulkAddAnnotation(v, i, O.REMOTE);
    } else
      o.bulkAddAnnotation(a.map(Y), i, O.REMOTE);
  }, h = (a, i) => {
    a ? s.setSelected(a, i) : s.clear();
  }, C = (a) => {
    s.clear(), s.setUserSelectAction(a);
  }, D = (a) => {
    if (n) {
      const i = n.parse(a).parsed, p = n.serialize(o.getAnnotation(i.id));
      return o.updateAnnotation(i), p;
    } else {
      const i = o.getAnnotation(a.id);
      return o.updateAnnotation(Y(a)), i;
    }
  };
  return {
    addAnnotation: f,
    cancelSelected: A,
    canRedo: t.canRedo,
    canUndo: t.canUndo,
    clearAnnotations: b,
    getAnnotationById: w,
    getAnnotations: m,
    getHistory: t.getHistory,
    getSelected: U,
    loadAnnotations: c,
    redo: t.redo,
    removeAnnotation: E,
    setAnnotations: T,
    setSelected: h,
    setUserSelectAction: C,
    undo: t.undo,
    updateAnnotation: D
  };
}, ze = (e, t, n) => typeof t == "function" ? t(e, n) : t, $e = (e, t) => typeof e != "function" && typeof t != "function" ? {
  ...e || {},
  ...t || {}
} : (n, o) => {
  const s = typeof e == "function" ? e(n, o) : e, f = typeof t == "function" ? t(n, o) : t;
  return {
    ...s || {},
    ...f || {}
  };
}, fe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let pe = (e) => crypto.getRandomValues(new Uint8Array(e)), ge = (e, t, n) => {
  let o = (2 << Math.log2(e.length - 1)) - 1, s = -~(1.6 * o * t / e.length);
  return (f = t) => {
    let A = "";
    for (; ; ) {
      let b = n(s), w = s | 0;
      for (; w--; )
        if (A += e[b[w] & o] || "", A.length >= f) return A;
    }
  };
}, he = (e, t = 21) => ge(e, t | 0, pe), me = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += fe[n[e] & 63];
  return t;
};
const Ve = () => ({ isGuest: !0, id: he("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), Ae = (e) => {
  const t = JSON.stringify(e);
  let n = 0;
  for (let o = 0, s = t.length; o < s; o++) {
    let f = t.charCodeAt(o);
    n = (n << 5) - n + f, n |= 0;
  }
  return `${n}`;
}, be = (e) => e ? typeof e == "object" ? { ...e } : e : void 0, _e = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {
  const { id: o, type: s, purpose: f, value: A, created: b, modified: w, creator: m, ...U } = n;
  return {
    id: o || `temp-${Ae(n)}`,
    annotation: t,
    type: s,
    purpose: f,
    value: A,
    creator: be(m),
    created: b ? new Date(b) : void 0,
    updated: w ? new Date(w) : void 0,
    ...U
  };
}), Ye = (e) => e.map((t) => {
  var b;
  const { annotation: n, created: o, updated: s, ...f } = t, A = {
    ...f,
    created: o == null ? void 0 : o.toISOString(),
    modified: s == null ? void 0 : s.toISOString()
  };
  return (b = A.id) != null && b.startsWith("temp-") && delete A.id, A;
}), ve = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], Ee = () => {
  const e = [...ve];
  return { assignRandomColor: () => {
    const o = Math.floor(Math.random() * e.length), s = e[o];
    return e.splice(o, 1), s;
  }, releaseColor: (o) => e.push(o) };
}, we = () => {
  const e = Ee();
  return { addUser: (o, s) => {
    const f = e.assignRandomColor();
    return {
      label: s.name || s.id,
      avatar: s.avatar,
      color: f
    };
  }, removeUser: (o) => e.releaseColor(o.appearance.color) };
}, Ce = (e, t) => e.every((n) => e.includes(n)) && t.every((n) => e.includes(n)), je = me(), Pe = (e = we()) => {
  const t = Q(), n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = (c, E) => {
    if (n.has(c)) {
      console.warn("Attempt to add user that is already present", c, E);
      return;
    }
    const T = e.addUser(c, E);
    n.set(c, {
      ...E,
      presenceKey: c,
      appearance: T
    });
  }, f = (c) => {
    const E = n.get(c);
    if (!E) {
      console.warn("Attempt to remove user that is not present", c);
      return;
    }
    e.removeUser(E), n.delete(c);
  }, A = (c) => {
    const E = new Set(c.map((C) => C.presenceKey)), T = c.filter(({ presenceKey: C }) => !n.has(C)), h = Array.from(n.values()).filter((C) => !E.has(C.presenceKey));
    T.forEach(({ presenceKey: C, user: D }) => s(C, D)), h.forEach((C) => {
      const { presenceKey: D } = C;
      o.has(D) && t.emit("selectionChange", C, null), f(D);
    }), (T.length > 0 || h.length > 0) && t.emit("presence", m());
  }, b = (c, E) => {
    const T = n.get(c);
    if (!T) {
      console.warn("Activity notification from user that is not present");
      return;
    }
    const h = o.get(c);
    (!h || !Ce(h, E)) && (o.set(c, E), t.emit("selectionChange", T, E));
  }, w = (c, E) => {
    const T = n.get(c);
    if (!T) {
      console.warn("Selection change for user that is not present", c);
      return;
    }
    E ? o.set(c, E) : o.delete(c), t.emit("selectionChange", T, E);
  }, m = () => [...Array.from(n.values())];
  return {
    getPresentUsers: m,
    notifyActivity: b,
    on: (c, E) => t.on(c, E),
    syncUsers: A,
    updateSelection: w
  };
};
export {
  de as Ignore,
  O as Origin,
  je as PRESENCE_KEY,
  Z as UserSelectAction,
  $e as chainStyles,
  ze as computeStyle,
  Ve as createAnonymousGuest,
  Ne as createBaseAnnotator,
  De as createBody,
  we as createDefaultAppearanceProvider,
  Ue as createHoverState,
  Ie as createLifecycleObserver,
  Pe as createPresenceState,
  Se as createSelectionState,
  Oe as createStore,
  Be as createUndoStack,
  xe as createViewportState,
  Ee as defaultColorProvider,
  J as diffAnnotations,
  Te as getContributors,
  ae as mergeChanges,
  W as onUserSelect,
  ue as parseAll,
  _e as parseW3CBodies,
  be as parseW3CUser,
  Y as reviveDates,
  ke as serializeAll,
  Ye as serializeW3CBodies,
  re as shouldNotify,
  Re as toSvelteStore
};
//# sourceMappingURL=annotorious-core.es.js.map
