import { Annotation, Annotator, AnnotatorState } from '../model';
import { Store } from './Store';
type Subscriber<T extends Annotation> = (annotation: T[]) => void;
export interface SvelteStore<T extends Annotation> extends Store<T> {
    subscribe(onChange: Subscriber<T>): void;
}
export interface SvelteAnnotatorState<I extends Annotation, E extends unknown> extends AnnotatorState<I, E> {
    store: SvelteStore<I>;
}
export interface SvelteAnnotator<I extends Annotation, E extends unknown> extends Annotator<I, E> {
    state: SvelteAnnotatorState<I, E>;
}
/**
 * A simple wrapper around the event-based store implementation
 * that adds a Svelte shim, for use with the reactive '$' notation.
 * Other frameworks might not actually need this. But it's pretty
 * convenient for everyone using Svelte, as well as for the
 * basic (Svelte-based) Annotorious standard implementation.
 */
export declare const toSvelteStore: <T extends Annotation = Annotation>(store: Store<T>) => SvelteStore<T>;
export {};
//# sourceMappingURL=SvelteStore.d.ts.map