{"version":3,"file":"annotorious-core.es.js","sources":["../../../node_modules/dequal/lite/index.mjs","../../../node_modules/svelte/src/runtime/internal/utils.js","../../../node_modules/svelte/src/runtime/store/index.js","../src/state/Hover.ts","../src/state/Selection.ts","../../../node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/uuid/dist/esm-browser/v4.js","../src/utils/annotationUtils.ts","../src/utils/diffAnnotations.ts","../src/state/StoreObserver.ts","../src/state/Store.ts","../src/state/SvelteStore.ts","../../../node_modules/nanoevents/index.js","../src/state/UndoStack.ts","../src/state/Viewport.ts","../src/lifecycle/Lifecycle.ts","../src/model/FormatAdapter.ts","../src/model/Annotator.ts","../src/model/DrawingStyle.ts","../../../node_modules/nanoid/url-alphabet/index.js","../../../node_modules/nanoid/index.browser.js","../src/model/User.ts","../src/model/W3CAnnotation.ts","../src/presence/ColorPalette.ts","../src/presence/AppearanceProvider.ts","../src/presence/PresenceState.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from 'svelte/store';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport type HoverState<T extends Annotation> = ReturnType<typeof createHoverState<T>>;\n\nexport const createHoverState = <T extends Annotation>(store: Store<T>) => {\n\n  const { subscribe, set } = writable<string | undefined>();\n\n  let currentHover: string | undefined;\n\n  subscribe(updated => currentHover = updated);\n\n  // Track store delete and update events\n  store.observe(( { changes }) => {    \n    if (currentHover) {\n      const isDeleted = (changes.deleted || []).some(a => a.id === currentHover);\n      if (isDeleted)\n        set(undefined);\n    \n      const updated = (changes.updated || []).find(({ oldValue }) => oldValue.id === currentHover);\n      if (updated)\n        set(updated.newValue.id);\n    }\n  });\n\n  return { \n    get current() { return currentHover },\n    subscribe, \n    set \n  };\n\n}\n","import { writable } from 'svelte/store';\nimport { dequal } from 'dequal/lite';\nimport type { Annotation, FormatAdapter } from '../model';\nimport type { Store } from './Store';\n\nexport interface Selection {\n\n  selected: { id: string, editable?: boolean }[],\n\n  event?: PointerEvent | KeyboardEvent;\n\n}\n\nexport type SelectionState<I extends Annotation, E extends unknown> = ReturnType<typeof createSelectionState<I, E>>;\n\nexport enum UserSelectAction {\n\n  EDIT = 'EDIT', // Make annotation target(s) editable on pointer select\n\n  SELECT = 'SELECT',  // Just select, but don't make editable\n\n  NONE = 'NONE' // Click won't select - the annotation is completely inert\n\n}\n\nexport type UserSelectActionExpression<T extends unknown> = UserSelectAction | ((a: T) => UserSelectAction);\n\nconst EMPTY: Selection = { selected: [] };\n\nexport const createSelectionState = <I extends Annotation, E extends unknown>(\n  store: Store<I>,\n  defaultSelectionAction?: UserSelectActionExpression<E>,\n  adapter?: FormatAdapter<I, E>\n) => {\n  const { subscribe, set } = writable<Selection>(EMPTY);\n\n  let currentUserSelectAction = defaultSelectionAction;\n\n  let currentSelection: Selection = EMPTY;\n\n  subscribe(updated => currentSelection = updated);\n\n  const clear = () => {\n    if (!dequal(currentSelection, EMPTY)) {\n      set(EMPTY);\n    }\n  };\n\n  const isEmpty = () => currentSelection.selected?.length === 0;\n\n  const isSelected = (annotationOrId: I | string) => {\n    if (isEmpty())\n      return false;\n\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n    return currentSelection.selected.some(i => i.id === id);\n  }\n\n  const userSelect = (idOrIds: string | string[], event?: Selection['event']) => {\n    let annotations: I[];\n\n    if (Array.isArray(idOrIds)) {\n      annotations = idOrIds.map(id => store.getAnnotation(id)!).filter(Boolean);\n\n      if (annotations.length < idOrIds.length) {\n        console.warn('Invalid selection: ' + idOrIds.filter(id => !annotations.some(a => a.id === id)));\n        return;\n      }\n    } else {\n      const annotation = store.getAnnotation(idOrIds);\n      if (!annotation) {\n        console.warn('Invalid selection: ' + idOrIds);\n        return;\n      }\n\n      annotations = [annotation];\n    }\n\n    const selected = annotations.reduce<{ id: string, editable?: boolean }[]>((sel, a) => {\n      const action = onUserSelect(a, currentUserSelectAction, adapter);\n      if (action === UserSelectAction.EDIT)\n        return [...sel, { id: a.id, editable: true }];\n      else if (action === UserSelectAction.SELECT) \n        return [...sel, { id: a.id }];\n      else\n        return sel;\n    }, []);\n\n    set({ selected, event });\n  }\n\n  const setSelected = (idOrIds: string | string[], editable?: boolean) => {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    // Remove invalid\n    const annotations = ids\n      .map(id => store.getAnnotation(id))\n      .filter((a): a is I => Boolean(a));\n\n    set({\n      selected: annotations.map(annotation => {\n\n        // If editable isn't set, use the default behavior\n        const isEditable = editable === undefined\n          ? onUserSelect(annotation, currentUserSelectAction, adapter) === UserSelectAction.EDIT\n          : editable;\n\n        return { id: annotation.id, editable: isEditable }\n      })\n    });\n\n    if (annotations.length !== ids.length)\n      console.warn('Invalid selection', idOrIds);\n  }\n\n  const removeFromSelection = (ids: string[]) => {\n    if (isEmpty())\n      return false;\n\n    const { selected } = currentSelection;\n\n    // Checks which of the given annotations are actually in the selection\n    const shouldRemove = selected.some(({ id }) => ids.includes(id));\n    if (shouldRemove)\n      set({ selected: selected.filter(({ id }) => !ids.includes(id)) });\n  }\n\n  const setUserSelectAction = (action: UserSelectActionExpression<E> | undefined) => {\n    currentUserSelectAction = action;\n    setSelected(currentSelection.selected.map(({ id }) => id));\n  };\n\n  // Track store delete and update events\n  store.observe(\n    ({ changes }) => removeFromSelection((changes.deleted || []).map(a => a.id))\n  );\n\n  return {\n    get event() {\n      return currentSelection ? currentSelection.event : null;\n    },\n    get selected() {\n      return currentSelection ? [...currentSelection.selected] : null;\n    },\n    get userSelectAction() {\n      return currentUserSelectAction;\n    },\n    clear,\n    isEmpty,\n    isSelected,\n    setSelected,\n    setUserSelectAction,\n    subscribe,\n    userSelect\n  };\n\n}\n\nexport const onUserSelect = <I extends Annotation, E extends unknown>(\n  annotation: I,\n  action?: UserSelectActionExpression<E>,\n  adapter?: FormatAdapter<I, E>\n): UserSelectAction => {\n  const crosswalked = adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n  return (typeof action === 'function') ? action(crosswalked) : (action || UserSelectAction.EDIT)\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || rng)();\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation, AnnotationBody } from '../model/Annotation';\nimport type {  User } from '../model/User';\n\n/**\n * Returns all users listed as creators or updaters in any parts of this\n * annotation.\n */\nexport const getContributors = (annotation: Annotation): User[] => {\n  const { creator, updatedBy } = annotation.target;\n\n  const bodyCollaborators = annotation.bodies.reduce((users, body) =>  (\n    [...users, body.creator, body.updatedBy].filter(Boolean) as User[]\n  ), [] as User[]);\n\n  return [\n    creator,\n    updatedBy,\n    ...bodyCollaborators\n  ].filter(u => u) as User[] // Remove undefined\n}\n\ntype HasTime = { created?: string | Date; updated?: string | Date; };\n\n/** \n * Converts any string dates in the given annotation(-like) \n * object to proper Date objects.\n */\nexport const reviveDates = <A extends Annotation = Annotation>(annotation: any): A => {\n  const revive = <T extends HasTime>(body: T): T => {\n    const revived = {...body};\n\n    if (body.created && typeof body.created === 'string')\n      revived.created = new Date(body.created);\n\n    if (body.updated && typeof body.updated === 'string')\n      revived.updated = new Date(body.updated);\n\n    return revived;\n  }\n\n  return {\n    ...annotation,\n    bodies: (annotation.bodies || []).map(revive),\n    target: revive(annotation.target)\n  } as A;\n}\n\n/**\n * Shorthand/helper.\n */\nexport const createBody = (\n  annotationOrId: string | Annotation, \n  payload: { [key: string]: any },\n  created?: Date,\n  creator?: User\n): AnnotationBody => ({\n  id: uuidv4(),\n  annotation: typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id,\n  created: created || new Date(),\n  creator,\n  ...payload\n});","import { dequal } from 'dequal/lite';\nimport type { Update } from '../state/StoreObserver';\nimport type { Annotation } from '../model/Annotation';\n\nconst getAddedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const oldBodyIds = new Set(oldValue.bodies.map(b => b.id));\n  return newValue.bodies.filter(b => !oldBodyIds.has(b.id));\n}\n\nconst getRemovedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const newBodyIds = new Set(newValue.bodies.map(b => b.id));\n  return oldValue.bodies.filter(b => !newBodyIds.has(b.id));\n}\n\nconst getChangedBodies = (oldValue: Annotation, newValue: Annotation) => \n  newValue.bodies\n    .map(newBody => {\n      const oldBody = oldValue.bodies.find(b => b.id === newBody.id);\n      return { newBody, oldBody: oldBody && !dequal(oldBody, newBody) ? oldBody : undefined }\n    })\n    .filter(({ oldBody }) => oldBody)\n    .map(({ oldBody, newBody }) => ({ oldBody: oldBody!, newBody }));\n\nconst hasTargetChanged = (oldValue: Annotation, newValue: Annotation) => \n  !dequal(oldValue.target, newValue.target);\n\nexport const diffAnnotations = <T extends Annotation = Annotation>(oldValue: T, newValue: T): Update<T> => {\n  const bodiesCreated = getAddedBodies(oldValue, newValue);\n  const bodiesDeleted = getRemovedBodies(oldValue, newValue);\n  const bodiesUpdated = getChangedBodies(oldValue, newValue);\n\n  return {\n    oldValue, \n    newValue,\n    bodiesCreated: bodiesCreated.length > 0 ? bodiesCreated : undefined,\n    bodiesDeleted: bodiesDeleted.length > 0 ? bodiesDeleted : undefined,\n    bodiesUpdated: bodiesUpdated.length > 0 ? bodiesUpdated : undefined,\n    targetUpdated: hasTargetChanged(oldValue, newValue) ? { oldTarget: oldValue.target, newTarget: newValue.target } : undefined\n  }\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model/Annotation';\nimport { diffAnnotations } from '../utils';\n\n/** Interface for listening to changes in the annotation store **/\nexport interface StoreObserver<T extends Annotation> { \n\n  onChange: { (event: StoreChangeEvent<T>): void };\n\n  options: StoreObserveOptions;\n\n}\n\n/** A change event fired when the store state changes **/\nexport interface StoreChangeEvent<T extends Annotation> {\n\n  origin: Origin;\n\n  changes: ChangeSet<T>;\n\n  state: T[];\n\n}\n\nexport interface ChangeSet<T extends Annotation> {\n\n  created?: T[];\n\n  deleted?: T[];\n\n  updated?: Update<T>[];\n\n}\n\nexport interface Update<T extends Annotation> {\n\n  oldValue: T;\n\n  newValue: T;\n\n  bodiesCreated?: T['bodies'];\n\n  bodiesDeleted?: T['bodies'];\n\n  bodiesUpdated?: Array<{ oldBody: T['bodies'][number], newBody: T['bodies'][number] }>;\n\n  targetUpdated?: { oldTarget: T['target'], newTarget: T['target'] };\n\n}\n\n/** Options to control which events the observer wants to get notified about **/\nexport interface StoreObserveOptions {\n\n  // Observe changes on targets, bodies or both?\n  ignore?: Ignore;\n\n  // Observe changes on one more specific annotations\n  annotations?: string | string[];\n\n  // Observer changes only for a specific origin\n  origin?: Origin\n\n}\n\n/** Allows the observer to ignore certain event types **/\nexport enum Ignore { \n\n  // Don't notify this observer for changes that involve bodies only\n  BODY_ONLY = 'BODY_ONLY',\n\n  // Don't notify for changes on targets only\n  TARGET_ONLY = 'TARGET_ONLY'\n\n}\n\n/** \n * Allows the observer to listen only for events that originated locally or from a remote source.\n * \n * SILENT should be used for updates that are not supposed to trigger an event. Remember that \n * with great power comes great responsibility: SILENT is really for Annotorious plugins and\n * extensions ONLY.\n */\nexport enum Origin { \n  \n  LOCAL = 'LOCAL', \n  \n  REMOTE = 'REMOTE',\n  \n  SILENT = 'SILENT'\n\n}\n\n/** Tests if this observer should be notified about this event **/\nexport const shouldNotify = <T extends Annotation>(observer: StoreObserver<T>, event: StoreChangeEvent<T>) => {\n  const { changes, origin } = event;\n\n  const isRelevantOrigin = observer.options.origin \n    ? observer.options.origin === origin \n    : origin !== Origin.SILENT;\n\n  if (!isRelevantOrigin)\n    return false;\n\n  if (observer.options.ignore) {\n    const { ignore } = observer.options;\n\n    // Shorthand\n    const has = (arg: any[] | undefined) => arg && arg.length > 0;\n\n    const hasAnnotationChanges =\n      has(changes.created) || has(changes.deleted);\n\n    if (!hasAnnotationChanges) {\n      const hasBodyChanges =\n        changes.updated?.some(u => has(u.bodiesCreated) || has(u.bodiesDeleted) || has(u.bodiesUpdated));\n    \n      const hasTargetChanges = \n        changes.updated?.some(u => u.targetUpdated);\n\n      if (ignore === Ignore.BODY_ONLY && hasBodyChanges && !hasTargetChanges)\n        return false;\n\n      if (ignore === Ignore.TARGET_ONLY && hasTargetChanges && !hasBodyChanges)\n        return false;\n    }\n  }\n\n  if (observer.options.annotations) {\n    // This observer has a filter set on specific annotations - check affected\n    const affectedAnnotations = new Set([\n      ...(changes.created || []).map(a => a.id),\n      ...(changes.deleted || []).map(a => a.id),\n      ...(changes.updated || []).map(({ oldValue }) => oldValue.id)\n    ]);\n\n    const observed = Array.isArray(observer.options.annotations) ?\n      observer.options.annotations : [ observer.options.annotations ];\n\n    return Boolean(observed.find(id => affectedAnnotations.has(id)));\n  } else {\n    return true;\n  }\n\n}\n\nexport const mergeChanges = <T extends Annotation>(changes: ChangeSet<T>, toMerge: ChangeSet<T>) => {\n  const previouslyCreatedIds = new Set((changes.created || []).map(a => a.id));\n  const previouslyUpdatedIds = new Set((changes.updated || []).map(({ newValue })=> newValue.id));\n\n  const createdIds = new Set((toMerge.created || []).map(a => a.id));\n  const deletedIds = new Set((toMerge.deleted || []).map(a => a.id));\n  const updatedIds = new Set((toMerge.updated || []).map(({ oldValue }) => oldValue.id));\n\n  // Updates that will be merged into create or previous update events\n  const mergeableUpdates = new Set((toMerge.updated || [])\n    .filter(({ oldValue }) => previouslyCreatedIds.has(oldValue.id) || previouslyUpdatedIds.has(oldValue.id))\n    .map(({ oldValue }) => oldValue.id ));\n\n  // * created *\n  // - drop created that were then deleted\n  // - merge any updates on created\n  // - append newly created\n  const created = [\n    ...(changes.created || [])\n      .filter(a => !deletedIds.has(a.id))\n      .map(a => updatedIds.has(a.id) \n        ? toMerge.updated!.find(({ oldValue }) => oldValue.id === a.id)!.newValue\n        : a),\n    ...(toMerge.created || [])\n  ];\n\n  // * deleted *\n  // - drop deleted that were later re-created (redo action!)\n  // - append newly deleted, but remove any that delete annotations \n  //   that were created in the same round\n  const deleted = [\n    ...(changes.deleted || [])\n      .filter(a => !createdIds.has(a.id)),\n    ...(toMerge.deleted || []) \n      .filter(a => !previouslyCreatedIds.has(a.id))\n  ] \n\n  // * updated *\n  // - drop updates on deleted annotations\n  // - merge any updates that override previous ones\n  // - append new updates, but remove any that were merged\n  const updated = [\n    ...(changes.updated || [])\n      .filter(({ newValue }) => !deletedIds.has(newValue.id))\n      .map(update => {\n        const { oldValue, newValue } = update;\n        if (updatedIds.has(newValue.id)) {\n          const updated = toMerge.updated!.find(u => u.oldValue.id === newValue.id)!.newValue;\n          return diffAnnotations(oldValue, updated);\n        } else {\n          return update;\n        }\n      }),\n    ...(toMerge.updated || []).filter(({ oldValue }) => !mergeableUpdates.has(oldValue.id))\n  ]\n\n  return { created, deleted, updated };\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation } from '../model';\nimport { diffAnnotations } from '../utils';\nimport { Origin, shouldNotify, type Update, type ChangeSet } from './StoreObserver';\nimport type { StoreObserver, StoreChangeEvent, StoreObserveOptions } from './StoreObserver';\n\n// Shorthand\ntype AnnotationBodyIdentifier = { id: string, annotation: string }; \n\nconst sanitize = <T extends Annotation>(a: Partial<T>): T => {\n  const id = a.id === undefined ? uuidv4() : a.id;\n\n  return {\n    ...a,\n    id,\n    bodies: a.bodies === undefined ? [] : a.bodies.map(b => ({\n      ...b,\n      annotation: id \n    })),\n    target: {\n      ...a.target,\n      annotation: id\n    }\n  } as T;\n}\n\nexport type Store<T extends Annotation> = ReturnType<typeof createStore<T>>;\n\nconst isAnnotation = <T extends Annotation>(arg: any): arg is T => arg.id !== undefined;\n\nexport const createStore = <T extends Annotation>() => {\n\n  const annotationIndex = new Map<string, T>();\n\n  const bodyIndex = new Map<string, string>();\n\n  const observers: StoreObserver<T>[] = [];\n\n  const observe = (onChange: { (event: StoreChangeEvent<T>): void }, options: StoreObserveOptions = {}) => {\n    observers.push({ onChange, options });\n  }\n\n  const unobserve = (onChange: { (event: StoreChangeEvent<T>): void }) => {\n    const idx = observers.findIndex(observer => observer.onChange == onChange);\n    if (idx > -1)\n      observers.splice(idx, 1);\n  }\n\n  const emit = (origin: Origin, changes: ChangeSet<T>) => {\n    const event: StoreChangeEvent<T> = {\n      origin,\n      changes: {\n        created: changes.created || [],\n        updated: changes.updated || [],\n        deleted: changes.deleted || []\n      },\n      state: [...annotationIndex.values()]\n    };\n\n    observers.forEach(observer => {\n      if (shouldNotify(observer, event))\n        observer.onChange(event);\n    });\n  }\n\n  const addAnnotation = (annotation: Partial<T>, origin = Origin.LOCAL) => {\n    const existing = annotation.id && annotationIndex.get(annotation.id);\n\n    if (existing) {\n      throw Error(`Cannot add annotation ${annotation.id} - exists already`);\n    } else {\n      const sanitized = sanitize(annotation);\n\n      annotationIndex.set(sanitized.id, sanitized);\n      sanitized.bodies.forEach(b => bodyIndex.set(b.id, sanitized.id));\n      emit(origin, { created: [sanitized] });\n    }\n  }\n\n  const updateOneAnnotation = (arg1: string | Partial<T>, arg2?: Partial<T> | Origin) => {\n    const updated: T = typeof arg1 === 'string' ? sanitize(arg2 as Partial<T>) : sanitize(arg1);\n\n    const oldId: string | undefined = typeof arg1 === 'string' ? arg1 : arg1.id;\n    const oldValue = oldId && annotationIndex.get(oldId);\n\n    if (oldValue) {\n      const update: Update<T> = diffAnnotations(oldValue, updated);\n\n      if (oldId === updated.id) {\n        annotationIndex.set(oldId, updated);\n      } else {\n        annotationIndex.delete(oldId);\n        annotationIndex.set(updated.id, updated);\n      }\n\n      oldValue.bodies.forEach(b => bodyIndex.delete(b.id));\n      updated.bodies.forEach(b => bodyIndex.set(b.id, updated.id));\n\n      return update;\n    } else {\n      console.warn(`Cannot update annotation ${oldId} - does not exist`);\n    }\n  }\n  \n  const updateAnnotation = (arg1: string | T, arg2: T | Origin = Origin.LOCAL, arg3 = Origin.LOCAL) => {\n    const origin: Origin = isAnnotation(arg2) ? arg3 : arg2;\n\n    const update = updateOneAnnotation(arg1, arg2);\n    if (update)\n      emit(origin, { updated: [update] })\n  }\n\n  const bulkUpdateAnnotation = (annotations: T[], origin = Origin.LOCAL) => {\n    const updated = annotations.reduce((updated, annotation) => {\n      const u = updateOneAnnotation(annotation);\n      return u ? [...updated, u] : updated;\n    }, [] as Update<T>[]);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const addBody = (body: T['bodies'][number], origin = Origin.LOCAL) => {\n    const oldValue = annotationIndex.get(body.annotation);\n    if (oldValue) {\n      const newValue = { \n        ...oldValue,\n        bodies: [ ...oldValue.bodies, body ]\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      bodyIndex.set(body.id, newValue.id);\n\n      const update: Update<T> = {\n        oldValue, newValue, bodiesCreated: [ body ]\n      };\n\n      emit(origin, { updated: [update] });\n    } else {\n      console.warn(`Attempt to add body to missing annotation: ${body.annotation}`);\n    }\n  }\n\n  const all = () => [...annotationIndex.values()];\n\n  const clear = (origin = Origin.LOCAL) => { \n    const all = [...annotationIndex.values()];\n\n    annotationIndex.clear();\n    bodyIndex.clear();\n\n    emit(origin, { deleted: all });\n  }\n\n  const bulkAddAnnotation = (annotations: Partial<T>[], replace = true, origin = Origin.LOCAL) => {\n    const sanitized = annotations.map(sanitize);\n\n    if (replace) {\n      // Delete existing first\n      const deleted = [...annotationIndex.values()];\n      annotationIndex.clear();\n      bodyIndex.clear();\n\n      sanitized.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: sanitized, deleted });\n    } else {\n      // Don't allow overwriting of existing annotations\n      const existing = annotations.reduce((all, next) => {\n        const existing = next.id && annotationIndex.get(next.id);\n        return existing ? [...all, existing ] : all;\n      }, [] as T[]);\n\n      if (existing.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${existing.map(a => a.id).join(', ')}`);\n\n      sanitized.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: sanitized });\n    }\n  }\n\n  const deleteOneAnnotation = (annotationOrId: T | string) => {\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n\n    const existing = annotationIndex.get(id);\n    if (existing) {\n      annotationIndex.delete(id);\n      existing.bodies.forEach(b => bodyIndex.delete(b.id));\n      return existing;\n    } else {\n      console.warn(`Attempt to delete missing annotation: ${id}`);\n    }\n  }\n\n  const deleteAnnotation = (annotationOrId: T | string, origin = Origin.LOCAL) => {\n    const deleted = deleteOneAnnotation(annotationOrId);\n    if (deleted)\n      emit(origin, { deleted: [ deleted  ]});\n  }\n\n  const bulkDeleteAnnotation = (annotationsOrIds: (T | string)[], origin = Origin.LOCAL) => {\n    const deleted = annotationsOrIds.reduce((deleted, arg) => {\n      const existing = deleteOneAnnotation(arg);\n      return existing ? [...deleted, existing] : deleted;\n    }, [] as T[]);\n\n    if (deleted.length > 0)\n      emit(origin, { deleted });\n  }\n\n  const deleteOneBody = (body: AnnotationBodyIdentifier) => {\n    const oldAnnotation = annotationIndex.get(body.annotation);\n\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === body.id);\n\n      if (oldBody) {\n        bodyIndex.delete(oldBody.id);\n\n        const newAnnotation = {\n          ...oldAnnotation,\n          bodies: oldAnnotation.bodies.filter(b => b.id !== body.id)\n        };\n\n        annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n        const update: Update<T> = {\n          oldValue: oldAnnotation, newValue: newAnnotation, bodiesDeleted: [oldBody]\n        };\n\n        return update;\n      } else {\n        console.warn(`Attempt to delete missing body ${body.id} from annotation ${body.annotation}`);\n      }\n    } else {\n      console.warn(`Attempt to delete body from missing annotation ${body.annotation}`);\n    }\n  }\n \n  const deleteBody = (body: AnnotationBodyIdentifier, origin = Origin.LOCAL) => {\n    const updated = deleteOneBody(body);\n    if (updated)\n      emit(origin, { updated: [ updated  ]});\n  }\n\n  const bulkDeleteBodies = (bodies: AnnotationBodyIdentifier[], origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => deleteOneBody(b)!)\n      .filter(Boolean);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const getAnnotation = (id: string): T | undefined => {\n    const a = annotationIndex.get(id);\n    return a ? {...a} : undefined;\n  }\n\n  const getBody = (id: string): T['bodies'][number] | undefined => {\n    const annotationId = bodyIndex.get(id);\n    if (annotationId) {\n      const annotation = getAnnotation(annotationId);\n      const body = annotation!.bodies.find(b => b.id === id);\n      if (body) {\n        return body;\n      } else {\n        console.error(`Store integrity error: body ${id} in index, but not in annotation`);\n      }\n    } else {\n      console.warn(`Attempt to retrieve missing body: ${id}`);\n    }\n  }\n\n  const updateOneBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number]) => {\n    if (oldBodyId.annotation !== newBody.annotation)\n      throw 'Annotation integrity violation: annotation ID must be the same when updating bodies';\n\n    const oldAnnotation = annotationIndex.get(oldBodyId.annotation);\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === oldBodyId.id)!;\n\n      const newAnnotation = { \n        ...oldAnnotation,\n        bodies: oldAnnotation.bodies.map(b => b.id === oldBody.id ? newBody : b)\n      };\n\n      annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n      if (oldBody.id !== newBody.id) {\n        bodyIndex.delete(oldBody.id);\n        bodyIndex.set(newBody.id, newAnnotation.id);\n      }\n\n      return {\n        oldValue: oldAnnotation, \n        newValue: newAnnotation,\n        bodiesUpdated: [{ oldBody, newBody }]\n      }\n    } else {\n      console.warn(`Attempt to add body to missing annotation ${oldBodyId.annotation}`);\n    }\n  }\n\n  const updateBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number], origin = Origin.LOCAL) => {\n    const update = updateOneBody(oldBodyId, newBody);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateBodies = (bodies: Array<T['bodies'][number]>, origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => updateOneBody({ id: b.id, annotation: b.annotation }, b)!)\n      .filter(Boolean);\n\n    emit(origin, { updated });\n  }\n\n  const updateOneTarget = (target: T['target']): Update<T> | undefined => {\n    const oldValue = annotationIndex.get(target.annotation);\n    \n    if (oldValue) {\n      const newValue = { \n        ...oldValue, \n        target: {\n          ...oldValue.target,\n          ...target \n        }\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      return {\n        oldValue, newValue, targetUpdated: { \n          oldTarget: oldValue.target,\n          newTarget: target\n        }\n      };\n    } else {\n      console.warn(`Attempt to update target on missing annotation: ${target.annotation}`);\n    }\n  }\n\n  const updateTarget = (target: T['target'], origin = Origin.LOCAL) => {\n    const update = updateOneTarget(target);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateTargets = (targets: Array<T['target']>, origin = Origin.LOCAL) => {\n    const updated = \n      targets.map(t => updateOneTarget(t)!).filter(Boolean);\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n\treturn {\n    addAnnotation,\n    addBody,\n    all,\n    bulkAddAnnotation,\n    bulkDeleteAnnotation,\n    bulkDeleteBodies,\n    bulkUpdateAnnotation,\n    bulkUpdateBodies,\n    bulkUpdateTargets,\n    clear,\n    deleteAnnotation,\n    deleteBody,\n    getAnnotation,\n    getBody,\n    observe,\n    unobserve,\n    updateAnnotation,\n    updateBody,\n    updateTarget\n\t};\n\n}\n","import type { Annotation, Annotator, AnnotatorState } from '../model';\nimport type { Store } from './Store';\nimport type { StoreChangeEvent } from './StoreObserver';\n\ntype Subscriber<T extends Annotation> = (annotation: T[]) => void; \n\nexport interface SvelteStore<T extends Annotation> extends Store<T> {\n\n  subscribe(onChange: Subscriber<T>): void;\n\n}\n\nexport interface SvelteAnnotatorState<I extends Annotation, E extends unknown> extends AnnotatorState<I, E> {\n\n  store: SvelteStore<I>\n\n}\n\nexport interface SvelteAnnotator<I extends Annotation, E extends unknown> extends Annotator<I, E> {\n\n  state: SvelteAnnotatorState<I, E>\n\n}\n\n/** \n * A simple wrapper around the event-based store implementation\n * that adds a Svelte shim, for use with the reactive '$' notation.\n * Other frameworks might not actually need this. But it's pretty\n * convenient for everyone using Svelte, as well as for the\n * basic (Svelte-based) Annotorious standard implementation.\n */\nexport const toSvelteStore = <T extends Annotation = Annotation>(store: Store<T>): SvelteStore<T> => {\n\n  const subscribe = (onChange: Subscriber<T>) => {\n\n    // Register a store observer on behalf of the subscriber\n    const shim = (event: StoreChangeEvent<T>) => onChange(event.state);\n    store.observe(shim);\n\n    // Immediately call the subscriber function with the\n    // current store value, according to the Svelte contract.\n    // https://stackoverflow.com/questions/68220955/how-does-svelte-unsubscribe-actually-work\n    onChange(store.all());\n\n    // Return the unsubscribe function\n    return () => store.unobserve(shim);\n  }\n\n  return {\n    ...store,\n    subscribe\n  }\n\n}","export let createNanoEvents = () => ({\n  emit(event, ...args) {\n    for (\n      let callbacks = this.events[event] || [],\n        i = 0,\n        length = callbacks.length;\n      i < length;\n      i++\n    ) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    ;(this.events[event] ||= []).push(cb)\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n","import { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\nimport { Origin } from './StoreObserver';\nimport { mergeChanges, type ChangeSet, type StoreChangeEvent, type Update } from './StoreObserver';\n\n// Duration with fast successive changes get merged \n// with the last event in the stack, rather than getting stacked\n// as a new undo/redo step.\nconst DEBOUNCE = 250;\n\nexport interface UndoStack <T extends Annotation> {\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  destroy(): void;\n\n  getHistory(): History<T>;\n\n  on<E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]): Unsubscribe;\n\n  undo(): void;\n\n  redo(): void;\n\n}\n\nexport interface UndoStackEvents <T extends Annotation> {\n\n  redo(change: ChangeSet<T>): void;\n\n  undo(change: ChangeSet<T>): void;\n\n}\n\nexport interface History <T extends Annotation> {\n\n  changes: ChangeSet<T>[];\n  \n  pointer: number;\n\n}\n\nexport const createUndoStack = <T extends Annotation>(store: Store<T>, history?: History<T>): UndoStack<T> => {\n\n  const emitter = createNanoEvents<UndoStackEvents<T>>();\n\n  const changeStack: ChangeSet<T>[] = history?.changes || [];\n\n  let pointer = history ? history.pointer : - 1;\n\n  let muteEvents = false;\n\n  let lastEvent = 0;\n\n  const onChange = (event: StoreChangeEvent<T>) => {\n    if (!muteEvents) {\n      const { changes } = event;\n\n      const now = performance.now();\n\n      if (now - lastEvent > DEBOUNCE) {\n        // Put this change on the stack...\n        changeStack.splice(pointer + 1);\n        changeStack.push(changes);\n\n        // ...and update the pointer\n        pointer = changeStack.length - 1;\n      } else {\n        // Merge this change with the last in the stack\n        const last = changeStack.length - 1;\n        changeStack[last] = mergeChanges(changeStack[last], changes);\n      }\n\n      lastEvent = now;\n    }\n\n    muteEvents = false;\n  }\n\n  store.observe(onChange, { origin: Origin.LOCAL });\n\n  const undoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkDeleteAnnotation(created);\n\n  const redoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkAddAnnotation(created, false);\n\n  const undoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotation(updated.map(({ oldValue }) => oldValue));\n      \n  const redoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotation(updated.map(({ newValue }) => newValue));\n\n  const undoDeleted = (deleted?: T[]) => \n    deleted && deleted.length > 0 && store.bulkAddAnnotation(deleted, false);\n\n  const redoDeleted = (deleted?: T[]) =>\n    deleted && deleted.length > 0 && store.bulkDeleteAnnotation(deleted);\n\n  const undo = () => {\n    if (pointer > -1) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer];\n\n      undoCreated(created);\n      undoUpdated(updated);\n      undoDeleted(deleted);\n\n      emitter.emit('undo', changeStack[pointer]);\n\n      pointer -= 1;\n    }\n  }\n\n  const canUndo = () => pointer > -1;\n\n  const redo = () => {\n    if (changeStack.length - 1 > pointer) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer + 1];\n\n      redoCreated(created);\n      redoUpdated(updated);\n      redoDeleted(deleted);\n\n      emitter.emit('redo', changeStack[pointer + 1]);\n\n      pointer += 1;\n    }\n  }\n\n  const canRedo = () => changeStack.length - 1 > pointer;\n\n  const destroy = () => store.unobserve(onChange);\n\n  const getHistory = () => ({ changes: [...changeStack], pointer });\n\n  const on = <E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]) => \n    emitter.on(event, callback);\n\n  return {\n    canRedo,\n    canUndo,\n    destroy,\n    getHistory,\n    on,\n    redo,\n    undo\n  }\n\n}","import { writable } from 'svelte/store';\n\nexport type ViewportState = ReturnType<typeof createViewportState>;\n\nexport const createViewportState = () => {\n\n  const { subscribe, set } = writable<string[]>([]);\n\n  return { \n    subscribe, \n    set\n  };\n\n}\n","import { dequal } from 'dequal/lite';\nimport type { Annotation, AnnotatorState, FormatAdapter } from '../model';\nimport { Origin } from '../state';\nimport type { ChangeSet, SelectionState, UndoStack } from '../state';\nimport type { LifecycleEvents } from './LifecycleEvents';\n\nexport type Lifecycle<I extends Annotation, E extends unknown> = \n  ReturnType<typeof createLifecycleObserver<I, E>>;\n\nexport const createLifecycleObserver = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I, E>,\n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>,\n  autoSave?: boolean\n) => {\n  const { hover, selection, store, viewport } = state;\n\n  const observers: Map<keyof LifecycleEvents, Function[]> = new Map();\n\n  // The currently selected annotations, in the state when they were selected \n  let initialSelection: I[] = [];\n\n  let currentHover: string | undefined;\n\n  let idleTimeout: ReturnType<typeof setTimeout>;\n\n  const on = <T extends keyof LifecycleEvents>(event: T, callback: LifecycleEvents<E>[T]) => {\n    if (observers.has(event)) {\n      observers.get(event)!.push(callback);\n    } else {\n      observers.set(event, [callback]);\n    }\n  }\n\n  const off = <T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]) => {\n    const callbacks = observers.get(event);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx !== -1)\n        callbacks.splice(idx, 1);\n    }\n  }\n\n  const emit = (event: keyof LifecycleEvents<E>, arg0: I | I[], arg1?: I | PointerEvent) => {\n    if (observers.has(event)) {\n      setTimeout(() => {\n        observers.get(event)!.forEach(callback => { \n          if (adapter) {\n            const serialized0 = Array.isArray(arg0) ? \n              arg0.map(a => adapter.serialize(a)) : adapter.serialize(arg0);\n            \n            const serialized1: E | PointerEvent | undefined =\n              arg1 ? arg1 instanceof PointerEvent ? arg1 : adapter.serialize(arg1) : undefined;\n\n            callback(serialized0 as E & E[], serialized1); \n          } else {\n            callback(arg0 as E & E[], arg1 as unknown as E);  \n          }\n        });\n      }, 1);\n    }\n  }\n\n  const onIdleUpdate = () => {\n    const { selected } = selection;\n\n    // User idle after activity - fire update events for selected\n    // annotations that changed\n    const updatedSelected = (selected || []).map(({ id }) => store.getAnnotation(id)!);\n\n    updatedSelected.forEach(updated => {\n      const initial = initialSelection.find(a => a.id === updated.id);\n      if (!initial || !dequal(initial, updated)) {\n        emit('updateAnnotation', updated, initial);\n      }\n    });\n\n    initialSelection = initialSelection.map(initial => {\n      const updated = updatedSelected.find(({ id }) => id === initial.id);\n      return updated ? updated : initial\n    });\n  }\n\n  selection.subscribe(({ selected })=> {\n    if (initialSelection.length === 0 && selected.length === 0)\n      return;\n\n    if (initialSelection.length === 0 && selected.length > 0) {\n      // A new selection was made - store the editable annotation as initial state\n      initialSelection = selected.map(({ id }) => store.getAnnotation(id)!);\n    } else if (initialSelection.length > 0 && selected.length === 0) {\n      // Deselect!\n      initialSelection.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);  \n        \n        if (updatedState && !dequal(updatedState, initial)) {\n          emit('updateAnnotation', updatedState, initial);\n        }\n      });\n\n      initialSelection = [];\n    } else {\n      // Changed selection\n      const initialIds = new Set(initialSelection.map(a => a.id));\n      const selectedIds = new Set(selected.map(({ id }) => id));\n\n      // Fire update events for deselected annotations that have changed\n      const deselected = initialSelection.filter(a => !selectedIds.has(a.id));\n      deselected.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);\n\n        if (updatedState && !dequal(updatedState, initial))\n          emit('updateAnnotation', updatedState, initial);\n      });\n\n      initialSelection = [\n        // Remove annotations that were deselected\n        ...initialSelection.filter(a => selectedIds.has(a.id)),\n        // Add editable annotations that were selected\n        ...selected\n          .filter(({ id }) => !initialIds.has(id))\n          .map(({ id }) => store.getAnnotation(id)!)\n      ];\n    }\n\n    emit('selectionChanged', initialSelection);\n  });\n\n  hover.subscribe(id => {\n    if (!currentHover && id) {\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    } else if (currentHover && !id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n    } else if (currentHover && id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    }\n\n    currentHover = id;\n  });\n\n  viewport?.subscribe(ids => \n    emit('viewportIntersect', ids.map(id => store.getAnnotation(id)!)));\n\n  store.observe(event => {\n    // autoSave option triggers update events on idleness\n    if (autoSave) {\n      if (idleTimeout)\n        clearTimeout(idleTimeout);\n\n      idleTimeout = setTimeout(onIdleUpdate, 1000);\n    }\n\n    // Local CREATE and DELETE events are applied immediately\n    const { created, deleted } = event.changes;\n    (created || []).forEach(a => emit('createAnnotation', a));\n    (deleted || []).forEach(a => emit('deleteAnnotation', a));\n\n    // Updates are only applied immediately if they involve body changes\n    const updatesWithBody = (event.changes.updated || []).filter(u => [\n      ...(u.bodiesCreated || []),\n      ...(u.bodiesDeleted || []),\n      ...(u.bodiesUpdated || [])\n    ].length > 0);\n\n    // Emit an update with the new annototation and the stored initial state\n    updatesWithBody.forEach(({ oldValue, newValue }) => {\n      const initial = initialSelection.find(a => a.id === oldValue.id) || oldValue;\n\n      // Record the update as the new last known state\n      initialSelection = initialSelection\n        .map(a => a.id === oldValue.id ? newValue : a);\n\n      emit('updateAnnotation', newValue, initial);\n    });\n  }, { origin: Origin.LOCAL });\n\n  // Track remote changes - these should update the initial state\n  store.observe(event => {\n    if (initialSelection) {\n      const selectedIds = new Set(initialSelection.map(a => a.id));\n\n      const relevantUpdates = (event.changes.updated || [])\n        .filter(({ newValue }) => selectedIds.has(newValue.id))\n        .map(({ newValue }) => newValue);\n\n      if (relevantUpdates.length > 0) {\n        initialSelection = initialSelection.map(selected => {\n          const updated = relevantUpdates.find(updated => updated.id === selected.id);\n          return updated ? updated : selected;\n        })\n      }\n    }\n  }, { origin: Origin.REMOTE });\n\n  const onUndoOrRedo = (undo: boolean) => (changes: ChangeSet<I>) => {\n    // Undo/redo of created/delete will cause lifecycle events automatically,\n    // but we need to handle updates specifically!\n    const { updated } = changes;\n\n    if (undo)\n      (updated || []).forEach(t => emit('updateAnnotation', t.oldValue, t.newValue));\n    else\n      (updated || []).forEach(t => emit('updateAnnotation', t.newValue, t.oldValue));\n  }\n\n  undoStack.on('undo', onUndoOrRedo(true));\n  undoStack.on('redo', onUndoOrRedo(false));\n\n  return { on, off, emit }\n\n}\n","import type { Annotation } from './Annotation';\n\nexport interface FormatAdapter<A extends Annotation, T extends unknown> {\n\n  parse(serialized: T): ParseResult<A>;\n\n  parseAll?(serialized: unknown[]): { parsed: A[], failed: T[] };\n\n  serialize(core: A): T;\n\n}\n\nexport interface ParseResult<A extends Annotation> {\n\n  parsed?: A;\n  \n  error?: Error;\n\n}\n\nexport const serializeAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (annotations: A[]) => annotations.map(a => adapter.serialize(a));\n\nexport const parseAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (serialized: T[]) => serialized.reduce((result, next) => {\n      const { parsed, error } = adapter.parse(next);\n      \n      return error ? {\n        parsed: result.parsed,\n        failed: [...result.failed, next ]\n      } : parsed ? {\n        parsed: [...result.parsed, parsed ],\n        failed: result.failed\n      } : {\n        ...result\n      }\n    }, { parsed: [] as A[], failed: [] as T[]});\n  ","import type { Annotation } from './Annotation';\nimport type { User } from './User';\nimport type { PresenceProvider } from '../presence';\nimport type {\n  History,\n  HoverState,\n  SelectionState,\n  Store,\n  UndoStack,\n  UserSelectActionExpression,\n  ViewportState\n} from '../state';\nimport { Origin } from '../state';\nimport type { LifecycleEvents } from '../lifecycle';\nimport { reviveDates } from '../utils';\nimport { type FormatAdapter, parseAll } from './FormatAdapter';\nimport type { DrawingStyleExpression } from './DrawingStyle';\nimport type { Filter } from './Filter';\n\n/**\n * Base annotator interface\n * @template I - internal core data model\n * @template E - external adapted representation\n */\nexport interface Annotator<I extends Annotation = Annotation, E extends unknown = Annotation> {\n\n  addAnnotation(annotation: Partial<E>): void;\n\n  cancelSelected(): void;\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  clearAnnotations(): void;\n\n  destroy(): void;\n\n  getAnnotationById(id: string): E | undefined;\n\n  getAnnotations(): E[];\n\n  getHistory(): History<I>;\n\n  getSelected(): E[];\n\n  getUser(): User;\n\n  loadAnnotations(url: string, replace?: boolean): Promise<E[]>;\n\n  redo(): void;\n\n  removeAnnotation(arg: Partial<E> | string): E | undefined;\n\n  setAnnotations(annotations: Partial<E>[], replace?: boolean): void;\n\n  setFilter(filter: Filter<I> | undefined): void;\n\n  setPresenceProvider?(provider: PresenceProvider): void;\n\n  setSelected(arg?: string | string[], editable?: boolean): void;\n\n  setStyle(style: DrawingStyleExpression<I> | undefined): void;\n\n  setUser(user: User): void;\n\n  setUserSelectAction(action: UserSelectActionExpression<E>): void;\n\n  setVisible(visible: boolean): void;\n\n  undo(): void;\n\n  updateAnnotation(annotation: Partial<E>): E;\n  \n  on<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  off<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  state: AnnotatorState<I, E>;\n\n}\n\nexport interface AnnotatorState<I extends Annotation, E extends unknown> {\n\n  store: Store<I>;\n\n  selection: SelectionState<I, E>;\n\n  hover: HoverState<I>;\n\n  viewport: ViewportState;\n\n}\n\nexport const createBaseAnnotator = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I, E>, \n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>\n) => {\n\n  const { store, selection } = state;\n\n  const addAnnotation = (annotation: E) => {\n    if (adapter) {\n      const { parsed, error } = adapter.parse(annotation);\n      if (parsed) {\n        store.addAnnotation(parsed, Origin.REMOTE);\n      } else {\n        console.error(error);\n      }\n    } else {\n      store.addAnnotation(reviveDates<I>(annotation), Origin.REMOTE);\n    }\n  }\n\n  const cancelSelected = () => selection.clear();\n\n  const clearAnnotations = () => store.clear();\n\n  const getAnnotationById = (id: string): E | undefined => {\n    const annotation = store.getAnnotation(id);\n    return (adapter && annotation) ?\n      adapter.serialize(annotation) as E : annotation as unknown as E;\n  }\n\n  const getAnnotations = () =>\n    (adapter ? store.all().map(adapter.serialize) : store.all()) as E[];\n\n  const getSelected = () => {\n    const selectedIds = selection.selected?.map(s => s.id) || [];\n\n    const selected = selectedIds.map(id => store.getAnnotation(id)!).filter(Boolean);\n\n    return adapter \n      ? selected.map(adapter.serialize) \n      : selected as unknown as E[];\n  }\n\n  const loadAnnotations = (url: string, replace = true) =>\n    fetch(url)\n      .then((response) => response.json())\n      .then((annotations) => {\n        setAnnotations(annotations, replace);\n        return annotations;\n      });\n\n  const removeAnnotation = (arg: E | string): E | undefined => {\n    if (typeof arg === 'string') {\n      const annotation = store.getAnnotation(arg);\n      store.deleteAnnotation(arg);\n\n      if (annotation)\n        return adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n    } else {\n      const annotation = adapter ? adapter.parse(arg).parsed : (arg as unknown as I);\n\n      if (annotation) {\n        store.deleteAnnotation(annotation);\n        return arg;\n      }\n    }\n  }\n\n  const setAnnotations = (annotations: E[], replace = true) => {\n    if (adapter) {\n      const parseFn = adapter.parseAll || parseAll(adapter);\n      const { parsed, failed } = parseFn(annotations);\n\n      if (failed.length > 0)\n        console.warn(`Discarded ${failed.length} invalid annotations`, failed);\n\n      store.bulkAddAnnotation(parsed, replace, Origin.REMOTE);\n    } else {\n      store.bulkAddAnnotation(annotations.map(reviveDates<I>), replace, Origin.REMOTE);\n    }\n  }\n\n  const setSelected = (arg?: string | string[], editable?: boolean) => {\n    if (arg) {\n      selection.setSelected(arg, editable);\n    } else {\n      selection.clear();\n    }\n  }\n\n  const setUserSelectAction = (action: UserSelectActionExpression<E>) => {\n    selection.clear();\n    selection.setUserSelectAction(action);\n  }\n\n  const updateAnnotation = (updated: E): E => {\n    if (adapter) {\n      const crosswalked = adapter.parse(updated).parsed!;\n      const previous = adapter.serialize(store.getAnnotation(crosswalked.id)!);\n      store.updateAnnotation(crosswalked);\n      return previous;\n    } else {\n      const previous = store.getAnnotation((updated as unknown as I).id);\n      store.updateAnnotation(reviveDates<I>(updated));\n      return previous as unknown as E;\n    }\n  }\n\n  // Note that we don't spread the undoStack - it has a .destroy()\n  // method that would likely get overwritten by other Annotator implementations\n  // if people are not careful.\n  return { \n    addAnnotation,\n    cancelSelected,\n    canRedo: undoStack.canRedo,\n    canUndo: undoStack.canUndo,\n    clearAnnotations,\n    getAnnotationById,\n    getAnnotations,\n    getHistory: undoStack.getHistory,\n    getSelected,\n    loadAnnotations,\n    redo: undoStack.redo,\n    removeAnnotation,\n    setAnnotations,\n    setSelected,\n    setUserSelectAction,\n    undo: undoStack.undo,\n    updateAnnotation\n  }\n\n}\n","import type { Annotation } from \"./Annotation\";\nimport type { AnnotationState } from \"./AnnotationState\";\n\ntype RGB = `rgb(${number}, ${number}, ${number})`;\n\ntype RGBA = `rgba(${number}, ${number}, ${number}, ${number})`;\n\ntype HEX = `#${string}`;\n\nexport type Color = RGB | RGBA | HEX;\n\nexport interface DrawingStyle {\n\n  fill?: Color;\n\n  fillOpacity?: number;\n\n  stroke?: Color;\n\n  strokeOpacity?: number;\n\n  strokeWidth?: number;\n\n}\n\nexport type DrawingStyleExpression<T extends Annotation = Annotation> =\n  DrawingStyle | ((annotation: T, state?: AnnotationState) => DrawingStyle | undefined);\n\n/** Utility functions **/\n\nexport const computeStyle = <T extends Annotation = Annotation>(\n  annotation: T,\n  style: DrawingStyleExpression<T>,\n  state?: AnnotationState\n) => {\n  return typeof style === 'function' ? style(annotation, state) : style;\n};\n\nexport const chainStyles = <T extends Annotation = Annotation>(\n  applyFirst: DrawingStyleExpression<T>,\n  applySecond: DrawingStyleExpression<T>\n) => {\n  if (typeof applyFirst !== 'function' && typeof applySecond !== 'function') {\n    // Simple case: just two objects\n    return {\n      ...(applyFirst || {}),\n      ...(applySecond || {})\n    };\n  } else {\n    // Return a function\n    return (a: T, state: AnnotationState) => {\n      const first = typeof applyFirst === 'function' ? applyFirst(a, state) : applyFirst;\n      const second = typeof applySecond === 'function' ? applySecond(a, state) : applySecond;\n\n      return {\n        ...(first || {}),\n        ...(second || {})\n      }\n    }\n  }\n}\n  \n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { customAlphabet } from 'nanoid';\n\nexport interface User {\n\n  id: string;\n\n  isGuest?: boolean;\n\n  name?: string;\n\n  avatar?: string;\n\n}\n\nexport const createAnonymousGuest = () => {\n  const nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', 20);\n  \n  return { isGuest: true, id: nanoid() }\n}","import type { AnnotationBody } from './Annotation';\n\nexport interface W3CAnnotation {\n\n  '@context': 'http://www.w3.org/ns/anno.jsonld';\n\n  type: 'Annotation';\n\n  id: string;\n\n  creator?: W3CUser;\n\n  created?: string;\n\n  modified?: string;\n\n  body: W3CAnnotationBody | W3CAnnotationBody[];\n\n  target: W3CAnnotationTarget | W3CAnnotationTarget[];\n\n  [key: string]: any;\n\n}\n\nexport interface W3CUser {\n\n  type?: string;\n\n  id: string;\n\n  name?: string;\n\n}\n\nexport interface W3CAnnotationBody {\n\n  type?: string;\n\n  id?: string;\n\n  purpose?: string;\n\n  value?: string;\n\n  source?: string;\n\n  creator?: W3CUser;\n\n  created?: string;\n\n  modified?: string;\n\n}\n\nexport interface W3CAnnotationTarget {\n\n  id?: string;\n\n  source: string;\n\n  selector?: AbstractW3CSelector;\n\n}\n\nexport interface AbstractW3CSelector { }\n\n// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\nconst hashCode = (obj: Object): string => {\n  const str = JSON.stringify(obj);\n\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    let chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return `${hash}`;\n}\n\nexport const parseW3CUser = (user?: any) => user\n  ? typeof user === 'object' ? { ...user } : user : undefined;\n\n/**\n * Helper to crosswalk the W3C annotation body to a list of core AnnotationBody objects.\n */\nexport const parseW3CBodies = (\n  body: W3CAnnotationBody | W3CAnnotationBody[],\n  annotationId: string\n) : AnnotationBody[] => (Array.isArray(body) ? body : [body]).map(body => {\n\n  // Extract properties that conform to the internal model, but keep custom props\n  const { id, type, purpose, value, created, modified, creator, ...rest } = body;\n\n  // The internal model strictly requires IDs. (Because multi-user scenarios\n  // will have problems without them.) In the W3C model, bodys *may* have IDs.\n  // We'll create ad-hoc IDs for bodies without IDs, but want to make sure that\n  // generating the ID is idempotent: the same body should always get the same ID.\n  // This will avoid unexpected results when checking for equality.  \n  return {\n    id: id || `temp-${hashCode(body)}`,\n    annotation: annotationId,\n    type,\n    purpose,\n    value,\n    creator: parseW3CUser(creator),\n    created: created ? new Date(created) : undefined,\n    updated: modified ? new Date(modified) : undefined,\n    ...rest\n  }\n\n});\n\n/** Serialization helper to remove core-specific fields from the annotation body **/\nexport const serializeW3CBodies = (bodies: AnnotationBody[]): W3CAnnotationBody[] =>\n  bodies.map(b => {\n    const { annotation: _a, created, updated, ...bodyRest } = b;\n\n    const w3cBody: W3CAnnotationBody =  {\n      ...bodyRest,\n      created: created?.toISOString(),\n      modified: updated?.toISOString()\n    }\n    if (w3cBody.id?.startsWith('temp-')) {\n      delete w3cBody.id;\n    }\n\n    return w3cBody;\n  });\n","// SEABORN_BRIGHT\nexport const DEFAULT_PALETTE: Palette = [\n  '#ff7c00', // orange\n  '#1ac938', // green\n  '#e8000b', // red\n  '#8b2be2', // purple\n  '#9f4800', // brown\n  '#f14cc1', // pink\n  '#ffc400', // khaki\n  '#00d7ff', // cyan\n  '#023eff'  // blue\n];\n\nexport type Palette = string[];","import type { User } from '../model/User';\nimport type { Appearance } from './Appearance';\nimport type { PresentUser } from './PresentUser';\nimport { DEFAULT_PALETTE } from './ColorPalette';\n\nexport interface AppearanceProvider {\n\n  addUser(presenceKey: string, user: User): Appearance;\n\n  removeUser(user: PresentUser): void;\n\n}\n\nexport const defaultColorProvider = () => {\n\n  const unassignedColors = [...DEFAULT_PALETTE];\n\n  const assignRandomColor = () => {\n    const rnd = Math.floor(Math.random() * unassignedColors.length);\n    const color = unassignedColors[rnd];\n\n    unassignedColors.splice(rnd, 1);\n\n    return color;\n  }\n\n  const releaseColor = (color: string) =>\n    unassignedColors.push(color);\n\n  return { assignRandomColor, releaseColor };\n\n}\n\nexport const createDefaultAppearanceProvider = () => {\n\n  const colorProvider = defaultColorProvider();\n\n  const addUser = (presenceKey: string, user: User): Appearance => {\n    const color = colorProvider.assignRandomColor();\n\n    return {\n      label: user.name || user.id,\n      avatar: user.avatar,\n      color\n    };\n  }\n\n  const removeUser = (user: PresentUser) =>\n    colorProvider.releaseColor(user.appearance.color);\n\n  return { addUser, removeUser }\n  \n}","import { nanoid } from 'nanoid';\nimport { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { User } from '../model/User';\nimport type { PresentUser } from './PresentUser';\nimport type { PresenceEvents } from './PresenceEvents';\nimport { createDefaultAppearanceProvider } from './AppearanceProvider';\nimport type { AppearanceProvider } from './AppearanceProvider';\n\nexport interface PresenceState {\n\n  // Get users currently present to this room\n  getPresentUsers(): PresentUser[];\n\n  // Notify of a given present user's activity on the given annotations\n  notifyActivity(presenceKey: string, annotationIds: string[]): void;\n\n  // Add a listener for the given presence event\n  on<E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]): Unsubscribe;\n\n  // Initial sync - which users are present under which keys\n  syncUsers(state: { presenceKey: string, user: User }[]): void;\n\n  // Update the selection state for the given prresent user\n  updateSelection(presenceKey: string, selection: string[] | null): void;\n\n}\n\nconst isListEqual = (listA: any[], listB: any[]) => \n  listA.every(a => listA.includes(a)) && listB.every(b => listA.includes(b));\n\n// This client's presence key\nexport const PRESENCE_KEY = nanoid();\n\nexport const createPresenceState = (\n  appearanceProvider: AppearanceProvider = createDefaultAppearanceProvider()\n): PresenceState => {\n\n  const emitter = createNanoEvents<PresenceEvents>();\n\n  const presentUsers = new Map<string, PresentUser>();\n\n  const selectionStates = new Map<string, string[]>();\n\n  const addUser = (presenceKey: string, user: User) => {\n    if (presentUsers.has(presenceKey)) {\n      console.warn('Attempt to add user that is already present', presenceKey, user);\n      return;    \n    }\n\n    const appearance = appearanceProvider.addUser(presenceKey, user);\n\n    presentUsers.set(presenceKey, { \n      ...user,\n      presenceKey,\n      appearance\n    });\n  }\n\n  const removeUser = (presenceKey: string) => {\n    const user = presentUsers.get(presenceKey);\n    if (!user) {\n      console.warn('Attempt to remove user that is not present', presenceKey);\n      return;\n    }\n\n    appearanceProvider.removeUser(user);\n\n    presentUsers.delete(presenceKey);\n  }\n\n  const syncUsers = (state: { presenceKey: string, user: User }[]) => {\n    // const keys = new Set(others.map(s => s.presenceKey));\n    const keys = new Set(state.map(s => s.presenceKey));\n\n    // These users need to be added to the presentUsers list\n    // const toAdd = others.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n    const toAdd = state.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n\n    // These users need to be dropped from the list\n    const toRemove = Array.from(presentUsers.values()).filter(presentUser =>\n      !keys.has(presentUser.presenceKey));\n\n    toAdd.forEach(({ presenceKey, user }) => addUser(presenceKey, user));\n\n    toRemove.forEach(user => {\n      const { presenceKey } = user;\n\n      // If this user has a selection, fire deselect event\n      if (selectionStates.has(presenceKey))\n        emitter.emit('selectionChange', user, null);\n\n      removeUser(presenceKey)\n    });\n\n    if (toAdd.length > 0 || toRemove.length > 0)\n      emitter.emit('presence', getPresentUsers());\n  }\n\n  const notifyActivity = (presenceKey: string, annotationIds: string[]) => {    \n    const user = presentUsers.get(presenceKey);\n    \n    if (!user) {\n      console.warn('Activity notification from user that is not present');\n      return;\n    }\n\n    const currentSelection = selectionStates.get(presenceKey);\n\n    // Was there a selection change we might have missed?\n    if (!currentSelection || !isListEqual(currentSelection, annotationIds)) {\n      selectionStates.set(presenceKey, annotationIds);\n      emitter.emit('selectionChange', user, annotationIds);\n    }\n  }\n\n  const updateSelection = (presenceKey: string, selection: string[] | null) => {\n    const from = presentUsers.get(presenceKey);\n    if (!from) {\n      console.warn('Selection change for user that is not present', presenceKey);\n      return;\n    }\n\n    if (selection)\n      selectionStates.set(presenceKey, selection);\n    else \n      selectionStates.delete(presenceKey);\n\n    emitter.emit('selectionChange', from, selection);\n  }\n\n  const getPresentUsers = () =>\n    [...Array.from(presentUsers.values())];\n    \n  const on = <E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]) =>\n    emitter.on(event, callback);\n\n  return {\n    getPresentUsers,\n    notifyActivity,\n    on,\n    syncUsers,\n    updateSelection\n  }\n\n}"],"names":["has","dequal","foo","bar","ctor","len","noop","safe_not_equal","a","b","subscriber_queue","writable","value","start","stop","subscribers","set","new_value","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","createHoverState","store","currentHover","updated","changes","oldValue","UserSelectAction","EMPTY","createSelectionState","defaultSelectionAction","adapter","currentUserSelectAction","currentSelection","clear","isEmpty","_a","isSelected","annotationOrId","id","userSelect","idOrIds","event","annotations","annotation","selected","sel","action","onUserSelect","setSelected","editable","ids","isEditable","removeFromSelection","setUserSelectAction","crosswalked","byteToHex","unsafeStringify","arr","offset","getRandomValues","rnds8","rng","randomUUID","native","v4","options","buf","rnds","getContributors","creator","updatedBy","bodyCollaborators","users","body","u","reviveDates","revive","revived","createBody","payload","created","uuidv4","getAddedBodies","newValue","oldBodyIds","getRemovedBodies","newBodyIds","getChangedBodies","newBody","oldBody","hasTargetChanged","diffAnnotations","bodiesCreated","bodiesDeleted","bodiesUpdated","Ignore","Origin","shouldNotify","observer","_b","origin","ignore","arg","hasBodyChanges","hasTargetChanges","affectedAnnotations","mergeChanges","toMerge","previouslyCreatedIds","previouslyUpdatedIds","createdIds","deletedIds","updatedIds","mergeableUpdates","deleted","sanitize","isAnnotation","createStore","annotationIndex","bodyIndex","observers","observe","onChange","unobserve","idx","emit","addAnnotation","sanitized","updateOneAnnotation","arg1","arg2","oldId","updateAnnotation","arg3","bulkUpdateAnnotation","addBody","all","bulkAddAnnotation","replace","existing","next","deleteOneAnnotation","deleteAnnotation","bulkDeleteAnnotation","annotationsOrIds","deleteOneBody","oldAnnotation","newAnnotation","deleteBody","bulkDeleteBodies","bodies","getAnnotation","getBody","annotationId","updateOneBody","oldBodyId","updateBody","bulkUpdateBodies","updateOneTarget","target","targets","t","toSvelteStore","shim","createNanoEvents","args","callbacks","length","cb","DEBOUNCE","createUndoStack","history","emitter","changeStack","pointer","muteEvents","lastEvent","now","last","undoCreated","redoCreated","undoUpdated","redoUpdated","undoDeleted","redoDeleted","callback","createViewportState","createLifecycleObserver","state","undoStack","autoSave","hover","selection","viewport","initialSelection","idleTimeout","on","off","arg0","serialized0","serialized1","onIdleUpdate","updatedSelected","initial","updatedState","initialIds","selectedIds","relevantUpdates","onUndoOrRedo","undo","serializeAll","parseAll","serialized","result","parsed","error","createBaseAnnotator","cancelSelected","clearAnnotations","getAnnotationById","getAnnotations","getSelected","s","loadAnnotations","url","response","setAnnotations","removeAnnotation","parseFn","failed","previous","computeStyle","style","chainStyles","applyFirst","applySecond","first","second","urlAlphabet","random","bytes","customRandom","alphabet","defaultSize","getRandom","mask","step","size","j","customAlphabet","nanoid","scopedUrlAlphabet","createAnonymousGuest","hashCode","obj","str","hash","chr","parseW3CUser","user","parseW3CBodies","type","purpose","modified","rest","serializeW3CBodies","bodyRest","w3cBody","DEFAULT_PALETTE","defaultColorProvider","unassignedColors","rnd","color","createDefaultAppearanceProvider","colorProvider","presenceKey","isListEqual","listA","listB","PRESENCE_KEY","createPresenceState","appearanceProvider","presentUsers","selectionStates","addUser","appearance","removeUser","syncUsers","keys","toAdd","toRemove","presentUser","getPresentUsers","notifyActivity","annotationIds","updateSelection","from"],"mappings":"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","x_google_ignoreList":[0,1,2,5,6,7,8,14,21,22]}