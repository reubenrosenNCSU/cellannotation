var hn = Object.defineProperty;
var gn = (e, t, n) => t in e ? hn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ze = (e, t, n) => gn(e, typeof t != "symbol" ? t + "" : t, n);
function j() {
}
function ft(e, t) {
  for (const n in t) e[n] = t[n];
  return (
    /** @type {T & S} */
    e
  );
}
function qt(e) {
  return e();
}
function wt() {
  return /* @__PURE__ */ Object.create(null);
}
function ge(e) {
  e.forEach(qt);
}
function K(e) {
  return typeof e == "function";
}
function Q(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function mn(e) {
  return Object.keys(e).length === 0;
}
function Jt(e, ...t) {
  if (e == null) {
    for (const o of t)
      o(void 0);
    return j;
  }
  const n = e.subscribe(...t);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function xe(e, t, n) {
  e.$$.on_destroy.push(Jt(t, n));
}
function pn(e, t, n, o) {
  if (e) {
    const i = Qt(e, t, n, o);
    return e[0](i);
  }
}
function Qt(e, t, n, o) {
  return e[1] && o ? ft(n.ctx.slice(), e[1](o(t))) : n.ctx;
}
function yn(e, t, n, o) {
  if (e[2] && o) {
    const i = e[2](o(n));
    if (t.dirty === void 0)
      return i;
    if (typeof i == "object") {
      const s = [], r = Math.max(t.dirty.length, i.length);
      for (let l = 0; l < r; l += 1)
        s[l] = t.dirty[l] | i[l];
      return s;
    }
    return t.dirty | i;
  }
  return t.dirty;
}
function _n(e, t, n, o, i, s) {
  if (i) {
    const r = Qt(t, n, o, s);
    e.p(r, i);
  }
}
function wn(e) {
  if (e.ctx.length > 32) {
    const t = [], n = e.ctx.length / 32;
    for (let o = 0; o < n; o++)
      t[o] = -1;
    return t;
  }
  return -1;
}
function bt(e) {
  const t = {};
  for (const n in e) n[0] !== "$" && (t[n] = e[n]);
  return t;
}
function Ke(e) {
  return e ?? "";
}
function he(e, t) {
  e.appendChild(t);
}
function B(e, t, n) {
  e.insertBefore(t, n || null);
}
function I(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function gt(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function C(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function Zt(e) {
  return document.createTextNode(e);
}
function se() {
  return Zt(" ");
}
function ae() {
  return Zt("");
}
function z(e, t, n, o) {
  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);
}
function d(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
function bn(e) {
  return Array.from(e.childNodes);
}
function ye(e, t, n) {
  e.classList.toggle(t, !!n);
}
function En(e, t, { bubbles: n = !1, cancelable: o = !1 } = {}) {
  return new CustomEvent(e, { detail: t, bubbles: n, cancelable: o });
}
let Re;
function Ue(e) {
  Re = e;
}
function xt() {
  if (!Re) throw new Error("Function called outside component initialization");
  return Re;
}
function Ne(e) {
  xt().$$.on_mount.push(e);
}
function Ie() {
  const e = xt();
  return (t, n, { cancelable: o = !1 } = {}) => {
    const i = e.$$.callbacks[t];
    if (i) {
      const s = En(
        /** @type {string} */
        t,
        n,
        { cancelable: o }
      );
      return i.slice().forEach((r) => {
        r.call(e, s);
      }), !s.defaultPrevented;
    }
    return !0;
  };
}
function me(e, t) {
  const n = e.$$.callbacks[t.type];
  n && n.slice().forEach((o) => o.call(this, t));
}
const Me = [], We = [];
let Le = [];
const Et = [], An = /* @__PURE__ */ Promise.resolve();
let ut = !1;
function Sn() {
  ut || (ut = !0, An.then($t));
}
function dt(e) {
  Le.push(e);
}
const $e = /* @__PURE__ */ new Set();
let Ee = 0;
function $t() {
  if (Ee !== 0)
    return;
  const e = Re;
  do {
    try {
      for (; Ee < Me.length; ) {
        const t = Me[Ee];
        Ee++, Ue(t), Tn(t.$$);
      }
    } catch (t) {
      throw Me.length = 0, Ee = 0, t;
    }
    for (Ue(null), Me.length = 0, Ee = 0; We.length; ) We.pop()();
    for (let t = 0; t < Le.length; t += 1) {
      const n = Le[t];
      $e.has(n) || ($e.add(n), n());
    }
    Le.length = 0;
  } while (Me.length);
  for (; Et.length; )
    Et.pop()();
  ut = !1, $e.clear(), Ue(e);
}
function Tn(e) {
  if (e.fragment !== null) {
    e.update(), ge(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(dt);
  }
}
function Mn(e) {
  const t = [], n = [];
  Le.forEach((o) => e.indexOf(o) === -1 ? t.push(o) : n.push(o)), n.forEach((o) => o()), Le = t;
}
const He = /* @__PURE__ */ new Set();
let be;
function re() {
  be = {
    r: 0,
    c: [],
    p: be
    // parent group
  };
}
function le() {
  be.r || ge(be.c), be = be.p;
}
function O(e, t) {
  e && e.i && (He.delete(e), e.i(t));
}
function P(e, t, n, o) {
  if (e && e.o) {
    if (He.has(e)) return;
    He.add(e), be.c.push(() => {
      He.delete(e), o && (n && e.d(1), o());
    }), e.o(t);
  } else o && o();
}
function ke(e) {
  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);
}
function ne(e) {
  e && e.c();
}
function ee(e, t, n) {
  const { fragment: o, after_update: i } = e.$$;
  o && o.m(t, n), dt(() => {
    const s = e.$$.on_mount.map(qt).filter(K);
    e.$$.on_destroy ? e.$$.on_destroy.push(...s) : ge(s), e.$$.on_mount = [];
  }), i.forEach(dt);
}
function te(e, t) {
  const n = e.$$;
  n.fragment !== null && (Mn(n.after_update), ge(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function vn(e, t) {
  e.$$.dirty[0] === -1 && (Me.push(e), Sn(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function oe(e, t, n, o, i, s, r = null, l = [-1]) {
  const a = Re;
  Ue(e);
  const c = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: j,
    not_equal: i,
    bound: wt(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (a ? a.$$.context : [])),
    // everything else
    callbacks: wt(),
    dirty: l,
    skip_bound: !1,
    root: t.target || a.$$.root
  };
  r && r(c.root);
  let u = !1;
  if (c.ctx = n ? n(e, t.props || {}, (f, h, ...y) => {
    const g = y.length ? y[0] : h;
    return c.ctx && i(c.ctx[f], c.ctx[f] = g) && (!c.skip_bound && c.bound[f] && c.bound[f](g), u && vn(e, f)), h;
  }) : [], c.update(), u = !0, ge(c.before_update), c.fragment = o ? o(c.ctx) : !1, t.target) {
    if (t.hydrate) {
      const f = bn(t.target);
      c.fragment && c.fragment.l(f), f.forEach(I);
    } else
      c.fragment && c.fragment.c();
    t.intro && O(e.$$.fragment), ee(e, t.target, t.anchor), $t();
  }
  Ue(a);
}
class ie {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Ze(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Ze(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    te(this, 1), this.$destroy = j;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, n) {
    if (!K(n))
      return j;
    const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return o.push(n), () => {
      const i = o.indexOf(n);
      i !== -1 && o.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !mn(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
const Ln = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(Ln);
var F = /* @__PURE__ */ ((e) => (e.ELLIPSE = "ELLIPSE", e.POLYGON = "POLYGON", e.RECTANGLE = "RECTANGLE", e))(F || {});
const mt = {}, pt = (e, t) => mt[e] = t, ht = (e) => mt[e.type].area(e), kn = (e, t, n) => mt[e.type].intersects(e, t, n), qe = (e) => {
  let t = 1 / 0, n = 1 / 0, o = -1 / 0, i = -1 / 0;
  return e.forEach(([s, r]) => {
    t = Math.min(t, s), n = Math.min(n, r), o = Math.max(o, s), i = Math.max(i, r);
  }), { minX: t, minY: n, maxX: o, maxY: i };
}, In = {
  area: (e) => Math.PI * e.geometry.rx * e.geometry.ry,
  intersects: (e, t, n) => {
    const { cx: o, cy: i, rx: s, ry: r } = e.geometry, l = 0, a = Math.cos(l), c = Math.sin(l), u = t - o, f = n - i, h = a * u + c * f, y = c * u - a * f;
    return h * h / (s * s) + y * y / (r * r) <= 1;
  }
};
pt(F.ELLIPSE, In);
const Bn = {
  area: (e) => {
    const { points: t } = e.geometry;
    let n = 0, o = t.length - 1;
    for (let i = 0; i < t.length; i++)
      n += (t[o][0] + t[i][0]) * (t[o][1] - t[i][1]), o = i;
    return Math.abs(0.5 * n);
  },
  intersects: (e, t, n) => {
    const { points: o } = e.geometry;
    let i = !1;
    for (let s = 0, r = o.length - 1; s < o.length; r = s++) {
      const l = o[s][0], a = o[s][1], c = o[r][0], u = o[r][1];
      a > n != u > n && t < (c - l) * (n - a) / (u - a) + l && (i = !i);
    }
    return i;
  }
};
pt(F.POLYGON, Bn);
const On = {
  area: (e) => e.geometry.w * e.geometry.h,
  intersects: (e, t, n) => t >= e.geometry.x && t <= e.geometry.x + e.geometry.w && n >= e.geometry.y && n <= e.geometry.y + e.geometry.h
};
pt(F.RECTANGLE, On);
const Je = (e) => Fe(e.target), Fe = (e) => {
  var t, n;
  return (e == null ? void 0 : e.annotation) !== void 0 && ((n = (t = e == null ? void 0 : e.selector) == null ? void 0 : t.geometry) == null ? void 0 : n.bounds) !== void 0;
}, Dn = (e, t = !1) => {
  const n = typeof e == "string" ? e : e.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, i = [...n.matchAll(o)][0], [s, r, l, a, c, u, f] = i;
  if (r !== "xywh") throw new Error("Unsupported MediaFragment: " + n);
  if (l && l !== "pixel") throw new Error(`Unsupported MediaFragment unit: ${l}`);
  const [h, y, g, m] = [a, c, u, f].map(parseFloat);
  return {
    type: F.RECTANGLE,
    geometry: {
      x: h,
      y,
      w: g,
      h: m,
      bounds: {
        minX: h,
        minY: t ? y - m : y,
        maxX: h + g,
        maxY: t ? y : y + m
      }
    }
  };
}, Yn = (e) => {
  const { x: t, y: n, w: o, h: i } = e;
  return {
    type: "FragmentSelector",
    conformsTo: "http://www.w3.org/TR/media-frags/",
    value: `xywh=pixel:${t},${n},${o},${i}`
  };
}, en = "http://www.w3.org/2000/svg", At = (e) => {
  const t = (o) => {
    Array.from(o.attributes).forEach((i) => {
      i.name.startsWith("on") && o.removeAttribute(i.name);
    });
  }, n = e.getElementsByTagName("script");
  return Array.from(n).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(e.querySelectorAll("*")).forEach(t), e;
}, Pn = (e) => {
  const o = new XMLSerializer().serializeToString(e.documentElement).replace("<svg>", `<svg xmlns="${en}">`);
  return new DOMParser().parseFromString(o, "image/svg+xml").documentElement;
}, Cn = (e) => {
  const n = new DOMParser().parseFromString(e, "image/svg+xml"), o = n.lookupPrefix(en), i = n.lookupNamespaceURI(null);
  return o || i ? At(n).firstChild : At(Pn(n)).firstChild;
}, Xn = (e) => {
  const [t, n, o] = e.match(/(<polygon points=["|'])([^("|')]*)/) || [], i = o.split(" ").map((s) => s.split(",").map(parseFloat));
  return {
    type: F.POLYGON,
    geometry: {
      points: i,
      bounds: qe(i)
    }
  };
}, Un = (e) => {
  const t = Cn(e), n = parseFloat(t.getAttribute("cx")), o = parseFloat(t.getAttribute("cy")), i = parseFloat(t.getAttribute("rx")), s = parseFloat(t.getAttribute("ry")), r = {
    minX: n - i,
    minY: o - s,
    maxX: n + i,
    maxY: o + s
  };
  return {
    type: F.ELLIPSE,
    geometry: {
      cx: n,
      cy: o,
      rx: i,
      ry: s,
      bounds: r
    }
  };
}, Rn = (e) => {
  const t = typeof e == "string" ? e : e.value;
  if (t.includes("<polygon points="))
    return Xn(t);
  if (t.includes("<ellipse "))
    return Un(t);
  throw "Unsupported SVG shape: " + t;
}, Nn = (e) => {
  let t;
  if (e.type === F.POLYGON) {
    const n = e.geometry, { points: o } = n;
    t = `<svg><polygon points="${o.map((i) => i.join(",")).join(" ")}" /></svg>`;
  } else if (e.type === F.ELLIPSE) {
    const n = e.geometry;
    t = `<svg><ellipse cx="${n.cx}" cy="${n.cy}" rx="${n.rx}" ry="${n.ry}" /></svg>`;
  }
  if (t)
    return { type: "SvgSelector", value: t };
  throw `Unsupported shape type: ${e.type}`;
}, W = [];
for (let e = 0; e < 256; ++e)
  W.push((e + 256).toString(16).slice(1));
function Vn(e, t = 0) {
  return (W[e[t + 0]] + W[e[t + 1]] + W[e[t + 2]] + W[e[t + 3]] + "-" + W[e[t + 4]] + W[e[t + 5]] + "-" + W[e[t + 6]] + W[e[t + 7]] + "-" + W[e[t + 8]] + W[e[t + 9]] + "-" + W[e[t + 10]] + W[e[t + 11]] + W[e[t + 12]] + W[e[t + 13]] + W[e[t + 14]] + W[e[t + 15]]).toLowerCase();
}
let et;
const Gn = new Uint8Array(16);
function jn() {
  if (!et) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    et = crypto.getRandomValues.bind(crypto);
  }
  return et(Gn);
}
const zn = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), St = { randomUUID: zn };
function tn(e, t, n) {
  if (St.randomUUID && !t && !e)
    return St.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || jn)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, Vn(o);
}
var Tt = Object.prototype.hasOwnProperty;
function _e(e, t) {
  var n, o;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && _e(e[o], t[o]); ) ;
      return o === -1;
    }
    if (!n || typeof e == "object") {
      o = 0;
      for (n in e)
        if (Tt.call(e, n) && ++o && !Tt.call(t, n) || !(n in t) || !_e(e[n], t[n])) return !1;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
function tt() {
}
function Hn(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
const Ae = [];
function yt(e, t = tt) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function i(l) {
    if (Hn(e, l) && (e = l, n)) {
      const a = !Ae.length;
      for (const c of o)
        c[1](), Ae.push(c, e);
      if (a) {
        for (let c = 0; c < Ae.length; c += 2)
          Ae[c][0](Ae[c + 1]);
        Ae.length = 0;
      }
    }
  }
  function s(l) {
    i(l(e));
  }
  function r(l, a = tt) {
    const c = [l, a];
    return o.add(c), o.size === 1 && (n = t(i, s) || tt), l(e), () => {
      o.delete(c), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: r };
}
const Fn = (e) => {
  const { subscribe: t, set: n } = yt();
  let o;
  return t((i) => o = i), e.observe(({ changes: i }) => {
    if (o) {
      (i.deleted || []).some((r) => r.id === o) && n(void 0);
      const s = (i.updated || []).find(({ oldValue: r }) => r.id === o);
      s && n(s.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: t,
    set: n
  };
};
var nn = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(nn || {});
const Ge = { selected: [] }, Kn = (e, t, n) => {
  const { subscribe: o, set: i } = yt(Ge);
  let s = t, r = Ge;
  o((g) => r = g);
  const l = () => {
    _e(r, Ge) || i(Ge);
  }, a = () => {
    var g;
    return ((g = r.selected) == null ? void 0 : g.length) === 0;
  }, c = (g) => {
    if (a())
      return !1;
    const m = typeof g == "string" ? g : g.id;
    return r.selected.some((A) => A.id === m);
  }, u = (g, m) => {
    let A;
    if (Array.isArray(g)) {
      if (A = g.map((_) => e.getAnnotation(_)).filter(Boolean), A.length < g.length) {
        console.warn("Invalid selection: " + g.filter((_) => !A.some((w) => w.id === _)));
        return;
      }
    } else {
      const _ = e.getAnnotation(g);
      if (!_) {
        console.warn("Invalid selection: " + g);
        return;
      }
      A = [_];
    }
    const p = A.reduce((_, w) => {
      const E = Mt(w, s, n);
      return E === "EDIT" ? [..._, { id: w.id, editable: !0 }] : E === "SELECT" ? [..._, { id: w.id }] : _;
    }, []);
    i({ selected: p, event: m });
  }, f = (g, m) => {
    const A = Array.isArray(g) ? g : [g], p = A.map((_) => e.getAnnotation(_)).filter((_) => !!_);
    i({
      selected: p.map((_) => {
        const w = m === void 0 ? Mt(_, s, n) === "EDIT" : m;
        return { id: _.id, editable: w };
      })
    }), p.length !== A.length && console.warn("Invalid selection", g);
  }, h = (g) => {
    if (a())
      return !1;
    const { selected: m } = r;
    m.some(({ id: A }) => g.includes(A)) && i({ selected: m.filter(({ id: A }) => !g.includes(A)) });
  }, y = (g) => {
    s = g, f(r.selected.map(({ id: m }) => m));
  };
  return e.observe(
    ({ changes: g }) => h((g.deleted || []).map((m) => m.id))
  ), {
    get event() {
      return r ? r.event : null;
    },
    get selected() {
      return r ? [...r.selected] : null;
    },
    get userSelectAction() {
      return s;
    },
    clear: l,
    isEmpty: a,
    isSelected: c,
    setSelected: f,
    setUserSelectAction: y,
    subscribe: o,
    userSelect: u
  };
}, Mt = (e, t, n) => {
  const o = n ? n.serialize(e) : e;
  return typeof t == "function" ? t(o) : t || "EDIT";
}, q = [];
for (let e = 0; e < 256; ++e)
  q.push((e + 256).toString(16).slice(1));
function Wn(e, t = 0) {
  return (q[e[t + 0]] + q[e[t + 1]] + q[e[t + 2]] + q[e[t + 3]] + "-" + q[e[t + 4]] + q[e[t + 5]] + "-" + q[e[t + 6]] + q[e[t + 7]] + "-" + q[e[t + 8]] + q[e[t + 9]] + "-" + q[e[t + 10]] + q[e[t + 11]] + q[e[t + 12]] + q[e[t + 13]] + q[e[t + 14]] + q[e[t + 15]]).toLowerCase();
}
let nt;
const qn = new Uint8Array(16);
function Jn() {
  if (!nt) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    nt = crypto.getRandomValues.bind(crypto);
  }
  return nt(qn);
}
const Qn = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vt = { randomUUID: Qn };
function on(e, t, n) {
  if (vt.randomUUID && !t && !e)
    return vt.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || Jn)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, Wn(o);
}
const ot = (e) => {
  const t = (n) => {
    const o = { ...n };
    return n.created && typeof n.created == "string" && (o.created = new Date(n.created)), n.updated && typeof n.updated == "string" && (o.updated = new Date(n.updated)), o;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(t),
    target: t(e.target)
  };
}, zi = (e, t, n, o) => ({
  id: on(),
  annotation: typeof e == "string" ? e : e.id,
  created: n || /* @__PURE__ */ new Date(),
  creator: o,
  ...t
}), Zn = (e, t) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
}, xn = (e, t) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
}, $n = (e, t) => t.bodies.map((n) => {
  const o = e.bodies.find((i) => i.id === n.id);
  return { newBody: n, oldBody: o && !_e(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), eo = (e, t) => !_e(e.target, t.target), sn = (e, t) => {
  const n = Zn(e, t), o = xn(e, t), i = $n(e, t);
  return {
    oldValue: e,
    newValue: t,
    bodiesCreated: n.length > 0 ? n : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: i.length > 0 ? i : void 0,
    targetUpdated: eo(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0
  };
};
var G = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(G || {});
const to = (e, t) => {
  var n, o;
  const { changes: i, origin: s } = t;
  if (!(e.options.origin ? e.options.origin === s : s !== "SILENT"))
    return !1;
  if (e.options.ignore) {
    const { ignore: r } = e.options, l = (a) => a && a.length > 0;
    if (!(l(i.created) || l(i.deleted))) {
      const a = (n = i.updated) == null ? void 0 : n.some((u) => l(u.bodiesCreated) || l(u.bodiesDeleted) || l(u.bodiesUpdated)), c = (o = i.updated) == null ? void 0 : o.some((u) => u.targetUpdated);
      if (r === "BODY_ONLY" && a && !c || r === "TARGET_ONLY" && c && !a)
        return !1;
    }
  }
  if (e.options.annotations) {
    const r = /* @__PURE__ */ new Set([
      ...(i.created || []).map((l) => l.id),
      ...(i.deleted || []).map((l) => l.id),
      ...(i.updated || []).map(({ oldValue: l }) => l.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((l) => r.has(l));
  } else
    return !0;
}, no = (e, t) => {
  const n = new Set((e.created || []).map((f) => f.id)), o = new Set((e.updated || []).map(({ newValue: f }) => f.id)), i = new Set((t.created || []).map((f) => f.id)), s = new Set((t.deleted || []).map((f) => f.id)), r = new Set((t.updated || []).map(({ oldValue: f }) => f.id)), l = new Set((t.updated || []).filter(({ oldValue: f }) => n.has(f.id) || o.has(f.id)).map(({ oldValue: f }) => f.id)), a = [
    ...(e.created || []).filter((f) => !s.has(f.id)).map((f) => r.has(f.id) ? t.updated.find(({ oldValue: h }) => h.id === f.id).newValue : f),
    ...t.created || []
  ], c = [
    ...(e.deleted || []).filter((f) => !i.has(f.id)),
    ...(t.deleted || []).filter((f) => !n.has(f.id))
  ], u = [
    ...(e.updated || []).filter(({ newValue: f }) => !s.has(f.id)).map((f) => {
      const { oldValue: h, newValue: y } = f;
      if (r.has(y.id)) {
        const g = t.updated.find((m) => m.oldValue.id === y.id).newValue;
        return sn(h, g);
      } else
        return f;
    }),
    ...(t.updated || []).filter(({ oldValue: f }) => !l.has(f.id))
  ];
  return { created: a, deleted: c, updated: u };
}, it = (e) => {
  const t = e.id === void 0 ? on() : e.id;
  return {
    ...e,
    id: t,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((n) => ({
      ...n,
      annotation: t
    })),
    target: {
      ...e.target,
      annotation: t
    }
  };
}, oo = (e) => e.id !== void 0, io = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (S, v = {}) => {
    n.push({ onChange: S, options: v });
  }, i = (S) => {
    const v = n.findIndex((b) => b.onChange == S);
    v > -1 && n.splice(v, 1);
  }, s = (S, v) => {
    const b = {
      origin: S,
      changes: {
        created: v.created || [],
        updated: v.updated || [],
        deleted: v.deleted || []
      },
      state: [...e.values()]
    };
    n.forEach((T) => {
      to(T, b) && T.onChange(b);
    });
  }, r = (S, v = G.LOCAL) => {
    if (S.id && e.get(S.id))
      throw Error(`Cannot add annotation ${S.id} - exists already`);
    {
      const b = it(S);
      e.set(b.id, b), b.bodies.forEach((T) => t.set(T.id, b.id)), s(v, { created: [b] });
    }
  }, l = (S, v) => {
    const b = it(typeof S == "string" ? v : S), T = typeof S == "string" ? S : S.id, Y = T && e.get(T);
    if (Y) {
      const D = sn(Y, b);
      return T === b.id ? e.set(T, b) : (e.delete(T), e.set(b.id, b)), Y.bodies.forEach((H) => t.delete(H.id)), b.bodies.forEach((H) => t.set(H.id, b.id)), D;
    } else
      console.warn(`Cannot update annotation ${T} - does not exist`);
  }, a = (S, v = G.LOCAL, b = G.LOCAL) => {
    const T = oo(v) ? b : v, Y = l(S, v);
    Y && s(T, { updated: [Y] });
  }, c = (S, v = G.LOCAL) => {
    const b = S.reduce((T, Y) => {
      const D = l(Y);
      return D ? [...T, D] : T;
    }, []);
    b.length > 0 && s(v, { updated: b });
  }, u = (S, v = G.LOCAL) => {
    const b = e.get(S.annotation);
    if (b) {
      const T = {
        ...b,
        bodies: [...b.bodies, S]
      };
      e.set(b.id, T), t.set(S.id, T.id), s(v, { updated: [{
        oldValue: b,
        newValue: T,
        bodiesCreated: [S]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${S.annotation}`);
  }, f = () => [...e.values()], h = (S = G.LOCAL) => {
    const v = [...e.values()];
    e.clear(), t.clear(), s(S, { deleted: v });
  }, y = (S, v = !0, b = G.LOCAL) => {
    const T = S.map(it);
    if (v) {
      const Y = [...e.values()];
      e.clear(), t.clear(), T.forEach((D) => {
        e.set(D.id, D), D.bodies.forEach((H) => t.set(H.id, D.id));
      }), s(b, { created: T, deleted: Y });
    } else {
      const Y = S.reduce((D, H) => {
        const J = H.id && e.get(H.id);
        return J ? [...D, J] : D;
      }, []);
      if (Y.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${Y.map((D) => D.id).join(", ")}`);
      T.forEach((D) => {
        e.set(D.id, D), D.bodies.forEach((H) => t.set(H.id, D.id));
      }), s(b, { created: T });
    }
  }, g = (S) => {
    const v = typeof S == "string" ? S : S.id, b = e.get(v);
    if (b)
      return e.delete(v), b.bodies.forEach((T) => t.delete(T.id)), b;
    console.warn(`Attempt to delete missing annotation: ${v}`);
  }, m = (S, v = G.LOCAL) => {
    const b = g(S);
    b && s(v, { deleted: [b] });
  }, A = (S, v = G.LOCAL) => {
    const b = S.reduce((T, Y) => {
      const D = g(Y);
      return D ? [...T, D] : T;
    }, []);
    b.length > 0 && s(v, { deleted: b });
  }, p = (S) => {
    const v = e.get(S.annotation);
    if (v) {
      const b = v.bodies.find((T) => T.id === S.id);
      if (b) {
        t.delete(b.id);
        const T = {
          ...v,
          bodies: v.bodies.filter((Y) => Y.id !== S.id)
        };
        return e.set(v.id, T), {
          oldValue: v,
          newValue: T,
          bodiesDeleted: [b]
        };
      } else
        console.warn(`Attempt to delete missing body ${S.id} from annotation ${S.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${S.annotation}`);
  }, _ = (S, v = G.LOCAL) => {
    const b = p(S);
    b && s(v, { updated: [b] });
  }, w = (S, v = G.LOCAL) => {
    const b = S.map((T) => p(T)).filter(Boolean);
    b.length > 0 && s(v, { updated: b });
  }, E = (S) => {
    const v = e.get(S);
    return v ? { ...v } : void 0;
  }, k = (S) => {
    const v = t.get(S);
    if (v) {
      const b = E(v).bodies.find((T) => T.id === S);
      if (b)
        return b;
      console.error(`Store integrity error: body ${S} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${S}`);
  }, X = (S, v) => {
    if (S.annotation !== v.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const b = e.get(S.annotation);
    if (b) {
      const T = b.bodies.find((D) => D.id === S.id), Y = {
        ...b,
        bodies: b.bodies.map((D) => D.id === T.id ? v : D)
      };
      return e.set(b.id, Y), T.id !== v.id && (t.delete(T.id), t.set(v.id, Y.id)), {
        oldValue: b,
        newValue: Y,
        bodiesUpdated: [{ oldBody: T, newBody: v }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${S.annotation}`);
  }, R = (S, v, b = G.LOCAL) => {
    const T = X(S, v);
    T && s(b, { updated: [T] });
  }, V = (S, v = G.LOCAL) => {
    const b = S.map((T) => X({ id: T.id, annotation: T.annotation }, T)).filter(Boolean);
    s(v, { updated: b });
  }, Z = (S) => {
    const v = e.get(S.annotation);
    if (v) {
      const b = {
        ...v,
        target: {
          ...v.target,
          ...S
        }
      };
      return e.set(v.id, b), {
        oldValue: v,
        newValue: b,
        targetUpdated: {
          oldTarget: v.target,
          newTarget: S
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${S.annotation}`);
  };
  return {
    addAnnotation: r,
    addBody: u,
    all: f,
    bulkAddAnnotation: y,
    bulkDeleteAnnotation: A,
    bulkDeleteBodies: w,
    bulkUpdateAnnotation: c,
    bulkUpdateBodies: V,
    bulkUpdateTargets: (S, v = G.LOCAL) => {
      const b = S.map((T) => Z(T)).filter(Boolean);
      b.length > 0 && s(v, { updated: b });
    },
    clear: h,
    deleteAnnotation: m,
    deleteBody: _,
    getAnnotation: E,
    getBody: k,
    observe: o,
    unobserve: i,
    updateAnnotation: a,
    updateBody: R,
    updateTarget: (S, v = G.LOCAL) => {
      const b = Z(S);
      b && s(v, { updated: [b] });
    }
  };
}, so = (e) => ({
  ...e,
  subscribe: (t) => {
    const n = (o) => t(o.state);
    return e.observe(n), t(e.all()), () => e.unobserve(n);
  }
});
let ro = () => ({
  emit(e, ...t) {
    for (let n = this.events[e] || [], o = 0, i = n.length; o < i; o++)
      n[o](...t);
  },
  events: {},
  on(e, t) {
    var n;
    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => t !== i);
    };
  }
});
const lo = 250, ao = (e, t) => {
  const n = ro(), o = (t == null ? void 0 : t.changes) || [];
  let i = t ? t.pointer : -1, s = !1, r = 0;
  const l = (g) => {
    if (!s) {
      const { changes: m } = g, A = performance.now();
      if (A - r > lo)
        o.splice(i + 1), o.push(m), i = o.length - 1;
      else {
        const p = o.length - 1;
        o[p] = no(o[p], m);
      }
      r = A;
    }
    s = !1;
  };
  e.observe(l, { origin: G.LOCAL });
  const a = (g) => g && g.length > 0 && e.bulkDeleteAnnotation(g), c = (g) => g && g.length > 0 && e.bulkAddAnnotation(g, !1), u = (g) => g && g.length > 0 && e.bulkUpdateAnnotation(g.map(({ oldValue: m }) => m)), f = (g) => g && g.length > 0 && e.bulkUpdateAnnotation(g.map(({ newValue: m }) => m)), h = (g) => g && g.length > 0 && e.bulkAddAnnotation(g, !1), y = (g) => g && g.length > 0 && e.bulkDeleteAnnotation(g);
  return {
    canRedo: () => o.length - 1 > i,
    canUndo: () => i > -1,
    destroy: () => e.unobserve(l),
    getHistory: () => ({ changes: [...o], pointer: i }),
    on: (g, m) => n.on(g, m),
    redo: () => {
      if (o.length - 1 > i) {
        s = !0;
        const { created: g, updated: m, deleted: A } = o[i + 1];
        c(g), f(m), y(A), n.emit("redo", o[i + 1]), i += 1;
      }
    },
    undo: () => {
      if (i > -1) {
        s = !0;
        const { created: g, updated: m, deleted: A } = o[i];
        a(g), u(m), h(A), n.emit("undo", o[i]), i -= 1;
      }
    }
  };
}, co = () => {
  const { subscribe: e, set: t } = yt([]);
  return {
    subscribe: e,
    set: t
  };
}, fo = (e, t, n, o) => {
  const { hover: i, selection: s, store: r, viewport: l } = e, a = /* @__PURE__ */ new Map();
  let c = [], u, f;
  const h = (p, _) => {
    a.has(p) ? a.get(p).push(_) : a.set(p, [_]);
  }, y = (p, _) => {
    const w = a.get(p);
    if (w) {
      const E = w.indexOf(_);
      E !== -1 && w.splice(E, 1);
    }
  }, g = (p, _, w) => {
    a.has(p) && setTimeout(() => {
      a.get(p).forEach((E) => {
        if (n) {
          const k = Array.isArray(_) ? _.map((R) => n.serialize(R)) : n.serialize(_), X = w ? w instanceof PointerEvent ? w : n.serialize(w) : void 0;
          E(k, X);
        } else
          E(_, w);
      });
    }, 1);
  }, m = () => {
    const { selected: p } = s, _ = (p || []).map(({ id: w }) => r.getAnnotation(w));
    _.forEach((w) => {
      const E = c.find((k) => k.id === w.id);
      (!E || !_e(E, w)) && g("updateAnnotation", w, E);
    }), c = c.map((w) => _.find(({ id: k }) => k === w.id) || w);
  };
  s.subscribe(({ selected: p }) => {
    if (!(c.length === 0 && p.length === 0)) {
      if (c.length === 0 && p.length > 0)
        c = p.map(({ id: _ }) => r.getAnnotation(_));
      else if (c.length > 0 && p.length === 0)
        c.forEach((_) => {
          const w = r.getAnnotation(_.id);
          w && !_e(w, _) && g("updateAnnotation", w, _);
        }), c = [];
      else {
        const _ = new Set(c.map((E) => E.id)), w = new Set(p.map(({ id: E }) => E));
        c.filter((E) => !w.has(E.id)).forEach((E) => {
          const k = r.getAnnotation(E.id);
          k && !_e(k, E) && g("updateAnnotation", k, E);
        }), c = [
          // Remove annotations that were deselected
          ...c.filter((E) => w.has(E.id)),
          // Add editable annotations that were selected
          ...p.filter(({ id: E }) => !_.has(E)).map(({ id: E }) => r.getAnnotation(E))
        ];
      }
      g("selectionChanged", c);
    }
  }), i.subscribe((p) => {
    !u && p ? g("mouseEnterAnnotation", r.getAnnotation(p)) : u && !p ? g("mouseLeaveAnnotation", r.getAnnotation(u)) : u && p && (g("mouseLeaveAnnotation", r.getAnnotation(u)), g("mouseEnterAnnotation", r.getAnnotation(p))), u = p;
  }), l == null || l.subscribe((p) => g("viewportIntersect", p.map((_) => r.getAnnotation(_)))), r.observe((p) => {
    o && (f && clearTimeout(f), f = setTimeout(m, 1e3));
    const { created: _, deleted: w } = p.changes;
    (_ || []).forEach((E) => g("createAnnotation", E)), (w || []).forEach((E) => g("deleteAnnotation", E)), (p.changes.updated || []).filter((E) => [
      ...E.bodiesCreated || [],
      ...E.bodiesDeleted || [],
      ...E.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: E, newValue: k }) => {
      const X = c.find((R) => R.id === E.id) || E;
      c = c.map((R) => R.id === E.id ? k : R), g("updateAnnotation", k, X);
    });
  }, { origin: G.LOCAL }), r.observe((p) => {
    if (c) {
      const _ = new Set(c.map((E) => E.id)), w = (p.changes.updated || []).filter(({ newValue: E }) => _.has(E.id)).map(({ newValue: E }) => E);
      w.length > 0 && (c = c.map((E) => w.find((X) => X.id === E.id) || E));
    }
  }, { origin: G.REMOTE });
  const A = (p) => (_) => {
    const { updated: w } = _;
    p ? (w || []).forEach((E) => g("updateAnnotation", E.oldValue, E.newValue)) : (w || []).forEach((E) => g("updateAnnotation", E.newValue, E.oldValue));
  };
  return t.on("undo", A(!0)), t.on("redo", A(!1)), { on: h, off: y, emit: g };
}, uo = (e) => (t) => t.reduce((n, o) => {
  const { parsed: i, error: s } = e.parse(o);
  return s ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : i ? {
    parsed: [...n.parsed, i],
    failed: n.failed
  } : {
    ...n
  };
}, { parsed: [], failed: [] }), ho = (e, t, n) => {
  const { store: o, selection: i } = e, s = (p) => {
    if (n) {
      const { parsed: _, error: w } = n.parse(p);
      _ ? o.addAnnotation(_, G.REMOTE) : console.error(w);
    } else
      o.addAnnotation(ot(p), G.REMOTE);
  }, r = () => i.clear(), l = () => o.clear(), a = (p) => {
    const _ = o.getAnnotation(p);
    return n && _ ? n.serialize(_) : _;
  }, c = () => n ? o.all().map(n.serialize) : o.all(), u = () => {
    var p;
    const _ = (((p = i.selected) == null ? void 0 : p.map((w) => w.id)) || []).map((w) => o.getAnnotation(w)).filter(Boolean);
    return n ? _.map(n.serialize) : _;
  }, f = (p, _ = !0) => fetch(p).then((w) => w.json()).then((w) => (y(w, _), w)), h = (p) => {
    if (typeof p == "string") {
      const _ = o.getAnnotation(p);
      if (o.deleteAnnotation(p), _)
        return n ? n.serialize(_) : _;
    } else {
      const _ = n ? n.parse(p).parsed : p;
      if (_)
        return o.deleteAnnotation(_), p;
    }
  }, y = (p, _ = !0) => {
    if (n) {
      const w = n.parseAll || uo(n), { parsed: E, failed: k } = w(p);
      k.length > 0 && console.warn(`Discarded ${k.length} invalid annotations`, k), o.bulkAddAnnotation(E, _, G.REMOTE);
    } else
      o.bulkAddAnnotation(p.map(ot), _, G.REMOTE);
  }, g = (p, _) => {
    p ? i.setSelected(p, _) : i.clear();
  }, m = (p) => {
    i.clear(), i.setUserSelectAction(p);
  }, A = (p) => {
    if (n) {
      const _ = n.parse(p).parsed, w = n.serialize(o.getAnnotation(_.id));
      return o.updateAnnotation(_), w;
    } else {
      const _ = o.getAnnotation(p.id);
      return o.updateAnnotation(ot(p)), _;
    }
  };
  return {
    addAnnotation: s,
    cancelSelected: r,
    canRedo: t.canRedo,
    canUndo: t.canUndo,
    clearAnnotations: l,
    getAnnotationById: a,
    getAnnotations: c,
    getHistory: t.getHistory,
    getSelected: u,
    loadAnnotations: f,
    redo: t.redo,
    removeAnnotation: h,
    setAnnotations: y,
    setSelected: g,
    setUserSelectAction: m,
    undo: t.undo,
    updateAnnotation: A
  };
}, Hi = (e, t, n) => typeof t == "function" ? t(e, n) : t, Fi = (e, t) => typeof e != "function" && typeof t != "function" ? {
  ...e || {},
  ...t || {}
} : (n, o) => {
  const i = typeof e == "function" ? e(n, o) : e, s = typeof t == "function" ? t(n, o) : t;
  return {
    ...i || {},
    ...s || {}
  };
}, go = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let mo = (e) => crypto.getRandomValues(new Uint8Array(e)), po = (e, t, n) => {
  let o = (2 << Math.log2(e.length - 1)) - 1, i = -~(1.6 * o * t / e.length);
  return (s = t) => {
    let r = "";
    for (; ; ) {
      let l = n(i), a = i | 0;
      for (; a--; )
        if (r += e[l[a] & o] || "", r.length >= s) return r;
    }
  };
}, yo = (e, t = 21) => po(e, t | 0, mo), _o = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += go[n[e] & 63];
  return t;
};
const wo = () => ({ isGuest: !0, id: yo("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), bo = (e) => {
  const t = JSON.stringify(e);
  let n = 0;
  for (let o = 0, i = t.length; o < i; o++) {
    let s = t.charCodeAt(o);
    n = (n << 5) - n + s, n |= 0;
  }
  return `${n}`;
}, rn = (e) => e ? typeof e == "object" ? { ...e } : e : void 0, Eo = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {
  const { id: o, type: i, purpose: s, value: r, created: l, modified: a, creator: c, ...u } = n;
  return {
    id: o || `temp-${bo(n)}`,
    annotation: t,
    type: i,
    purpose: s,
    value: r,
    creator: rn(c),
    created: l ? new Date(l) : void 0,
    updated: a ? new Date(a) : void 0,
    ...u
  };
}), Ao = (e) => e.map((t) => {
  var n;
  const { annotation: o, created: i, updated: s, ...r } = t, l = {
    ...r,
    created: i == null ? void 0 : i.toISOString(),
    modified: s == null ? void 0 : s.toISOString()
  };
  return (n = l.id) != null && n.startsWith("temp-") && delete l.id, l;
}), So = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], Ki = () => {
  const e = [...So];
  return { assignRandomColor: () => {
    const t = Math.floor(Math.random() * e.length), n = e[t];
    return e.splice(t, 1), n;
  }, releaseColor: (t) => e.push(t) };
};
_o();
const Wi = (e, t = { strict: !0, invertY: !1 }) => ({ parse: (i) => To(i, t), serialize: (i) => Mo(i, e, t) }), To = (e, t = { strict: !0, invertY: !1 }) => {
  const n = e.id || tn(), {
    creator: o,
    created: i,
    modified: s,
    body: r,
    ...l
  } = e, a = Eo(r || [], n), c = Array.isArray(e.target) ? e.target[0] : e.target, u = Array.isArray(c.selector) ? c.selector[0] : c.selector, f = (u == null ? void 0 : u.type) === "FragmentSelector" ? Dn(u, t.invertY) : (u == null ? void 0 : u.type) === "SvgSelector" ? Rn(u) : void 0;
  return f || !t.strict ? {
    parsed: {
      ...l,
      id: n,
      bodies: a,
      target: {
        created: i ? new Date(i) : void 0,
        creator: rn(o),
        updated: s ? new Date(s) : void 0,
        ...Array.isArray(l.target) ? l.target[0] : l.target,
        annotation: n,
        selector: f || u
      }
    }
  } : {
    error: Error(`Invalid selector: ${JSON.stringify(u)}`)
  };
}, Mo = (e, t, n = { strict: !0, invertY: !1 }) => {
  const {
    selector: o,
    creator: i,
    created: s,
    updated: r,
    updatedBy: l,
    // Excluded from serialization
    ...a
  } = e.target;
  let c;
  try {
    c = o.type == F.RECTANGLE ? Yn(o.geometry) : Nn(o);
  } catch (f) {
    if (n.strict)
      throw f;
    c = o;
  }
  const u = {
    ...e,
    "@context": "http://www.w3.org/ns/anno.jsonld",
    id: e.id,
    type: "Annotation",
    body: Ao(e.bodies),
    created: s == null ? void 0 : s.toISOString(),
    creator: i,
    modified: r == null ? void 0 : r.toISOString(),
    target: {
      ...a,
      source: t,
      selector: c
    }
  };
  return delete u.bodies, "annotation" in u.target && delete u.target.annotation, u;
};
function Lt(e, t, n) {
  const o = e.slice();
  return o[10] = t[n], o[12] = n, o;
}
function kt(e) {
  let t, n;
  return t = new Pe({
    props: {
      x: (
        /*point*/
        e[10][0]
      ),
      y: (
        /*point*/
        e[10][1]
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), t.$on("pointerdown", function() {
    K(
      /*grab*/
      e[9](`HANDLE-${/*idx*/
      e[12]}`)
    ) && e[9](`HANDLE-${/*idx*/
    e[12]}`).apply(this, arguments);
  }), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, i) {
      e = o;
      const s = {};
      i & /*geom*/
      16 && (s.x = /*point*/
      e[10][0]), i & /*geom*/
      16 && (s.y = /*point*/
      e[10][1]), i & /*viewportScale*/
      8 && (s.scale = /*viewportScale*/
      e[3]), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
function vo(e) {
  let t, n, o, i, s, r, l, a, c, u, f, h = ke(
    /*geom*/
    e[4].points
  ), y = [];
  for (let m = 0; m < h.length; m += 1)
    y[m] = kt(Lt(e, h, m));
  const g = (m) => P(y[m], 1, 1, () => {
    y[m] = null;
  });
  return {
    c() {
      t = C("polygon"), i = se(), s = C("polygon"), l = se();
      for (let m = 0; m < y.length; m += 1)
        y[m].c();
      a = ae(), d(t, "class", "a9s-outer"), d(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), d(t, "points", o = /*geom*/
      e[4].points.map(It).join(" ")), d(s, "class", "a9s-inner a9s-shape-handle"), d(
        s,
        "style",
        /*computedStyle*/
        e[1]
      ), d(s, "points", r = /*geom*/
      e[4].points.map(Bt).join(" "));
    },
    m(m, A) {
      B(m, t, A), B(m, i, A), B(m, s, A), B(m, l, A);
      for (let p = 0; p < y.length; p += 1)
        y[p] && y[p].m(m, A);
      B(m, a, A), c = !0, u || (f = [
        z(t, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        }),
        z(s, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        })
      ], u = !0);
    },
    p(m, A) {
      if (e = m, (!c || A & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      e[1] ? "display:none;" : void 0)) && d(t, "style", n), (!c || A & /*geom*/
      16 && o !== (o = /*geom*/
      e[4].points.map(It).join(" "))) && d(t, "points", o), (!c || A & /*computedStyle*/
      2) && d(
        s,
        "style",
        /*computedStyle*/
        e[1]
      ), (!c || A & /*geom*/
      16 && r !== (r = /*geom*/
      e[4].points.map(Bt).join(" "))) && d(s, "points", r), A & /*geom, viewportScale, grab*/
      536) {
        h = ke(
          /*geom*/
          e[4].points
        );
        let p;
        for (p = 0; p < h.length; p += 1) {
          const _ = Lt(e, h, p);
          y[p] ? (y[p].p(_, A), O(y[p], 1)) : (y[p] = kt(_), y[p].c(), O(y[p], 1), y[p].m(a.parentNode, a));
        }
        for (re(), p = h.length; p < y.length; p += 1)
          g(p);
        le();
      }
    },
    i(m) {
      if (!c) {
        for (let A = 0; A < h.length; A += 1)
          O(y[A]);
        c = !0;
      }
    },
    o(m) {
      y = y.filter(Boolean);
      for (let A = 0; A < y.length; A += 1)
        P(y[A]);
      c = !1;
    },
    d(m) {
      m && (I(t), I(i), I(s), I(l), I(a)), gt(y, m), u = !1, ge(f);
    }
  };
}
function Lo(e) {
  let t, n;
  return t = new an({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[5]
      ),
      $$slots: {
        default: [
          vo,
          ({ grab: o }) => ({ 9: o }),
          ({ grab: o }) => o ? 512 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "change",
    /*change_handler*/
    e[6]
  ), t.$on(
    "grab",
    /*grab_handler*/
    e[7]
  ), t.$on(
    "release",
    /*release_handler*/
    e[8]
  ), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, [i]) {
      const s = {};
      i & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i & /*$$scope, geom, viewportScale, grab, computedStyle*/
      8730 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
const It = (e) => e.join(","), Bt = (e) => e.join(",");
function ko(e, t, n) {
  let o, { shape: i } = t, { computedStyle: s } = t, { transform: r } = t, { viewportScale: l = 1 } = t;
  const a = (h, y, g) => {
    let m;
    const A = h.geometry;
    y === "SHAPE" ? m = A.points.map(([_, w]) => [_ + g[0], w + g[1]]) : m = A.points.map(([_, w], E) => y === `HANDLE-${E}` ? [_ + g[0], w + g[1]] : [_, w]);
    const p = qe(m);
    return { ...h, geometry: { points: m, bounds: p } };
  };
  function c(h) {
    me.call(this, e, h);
  }
  function u(h) {
    me.call(this, e, h);
  }
  function f(h) {
    me.call(this, e, h);
  }
  return e.$$set = (h) => {
    "shape" in h && n(0, i = h.shape), "computedStyle" in h && n(1, s = h.computedStyle), "transform" in h && n(2, r = h.transform), "viewportScale" in h && n(3, l = h.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(4, o = i.geometry);
  }, [
    i,
    s,
    r,
    l,
    o,
    a,
    c,
    u,
    f
  ];
}
class Io extends ie {
  constructor(t) {
    super(), oe(this, t, ko, Lo, Q, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 3
    });
  }
}
const st = (e, t) => {
  const n = Math.abs(t[0] - e[0]), o = Math.abs(t[1] - e[1]);
  return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));
}, Se = [];
function Bo(e, t = j) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function i(l) {
    if (Q(e, l) && (e = l, n)) {
      const a = !Se.length;
      for (const c of o)
        c[1](), Se.push(c, e);
      if (a) {
        for (let c = 0; c < Se.length; c += 2)
          Se[c][0](Se[c + 1]);
        Se.length = 0;
      }
    }
  }
  function s(l) {
    i(l(e));
  }
  function r(l, a = j) {
    const c = [l, a];
    return o.add(c), o.size === 1 && (n = t(i, s) || j), l(e), () => {
      o.delete(c), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: r };
}
const Oo = (e, t) => {
  const { naturalWidth: n, naturalHeight: o } = e;
  if (!n && !o) {
    const { width: i, height: s } = e;
    t.setAttribute("viewBox", `0 0 ${i} ${s}`), e.addEventListener("load", (r) => {
      const l = r.target;
      t.setAttribute("viewBox", `0 0 ${l.naturalWidth} ${l.naturalHeight}`);
    });
  } else
    t.setAttribute("viewBox", `0 0 ${n} ${o}`);
}, Do = (e, t) => {
  Oo(e, t);
  const { subscribe: n, set: o } = Bo(1);
  let i;
  return window.ResizeObserver && (i = new ResizeObserver(() => {
    const r = t.getBoundingClientRect(), { width: l, height: a } = t.viewBox.baseVal, c = Math.max(
      r.width / l,
      r.height / a
    );
    o(c);
  }), i.observe(t.parentElement)), { destroy: () => {
    i && i.disconnect();
  }, subscribe: n };
}, Yo = typeof window > "u" || typeof navigator > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0 || // @ts-ignore
navigator.msMaxTouchPoints > 0;
function Po(e) {
  let t, n, o, i, s, r;
  return {
    c() {
      t = C("rect"), d(t, "class", n = Ke(`a9s-handle ${/*$$props*/
      e[8].class || ""}`.trim()) + " svelte-1sgkh33"), d(t, "x", o = /*x*/
      e[0] - /*handleSize*/
      e[5] / 2), d(t, "y", i = /*y*/
      e[1] - /*handleSize*/
      e[5] / 2), d(
        t,
        "width",
        /*handleSize*/
        e[5]
      ), d(
        t,
        "height",
        /*handleSize*/
        e[5]
      );
    },
    m(l, a) {
      B(l, t, a), s || (r = z(
        t,
        "pointerdown",
        /*pointerdown_handler_2*/
        e[11]
      ), s = !0);
    },
    p(l, a) {
      a & /*$$props*/
      256 && n !== (n = Ke(`a9s-handle ${/*$$props*/
      l[8].class || ""}`.trim()) + " svelte-1sgkh33") && d(t, "class", n), a & /*x, handleSize*/
      33 && o !== (o = /*x*/
      l[0] - /*handleSize*/
      l[5] / 2) && d(t, "x", o), a & /*y, handleSize*/
      34 && i !== (i = /*y*/
      l[1] - /*handleSize*/
      l[5] / 2) && d(t, "y", i), a & /*handleSize*/
      32 && d(
        t,
        "width",
        /*handleSize*/
        l[5]
      ), a & /*handleSize*/
      32 && d(
        t,
        "height",
        /*handleSize*/
        l[5]
      );
    },
    d(l) {
      l && I(t), s = !1, r();
    }
  };
}
function Co(e) {
  let t, n, o, i, s, r, l, a, c;
  return {
    c() {
      t = C("g"), n = C("circle"), i = C("rect"), d(
        n,
        "cx",
        /*x*/
        e[0]
      ), d(
        n,
        "cy",
        /*y*/
        e[1]
      ), d(n, "r", o = /*radius*/
      e[3] / /*scale*/
      e[2]), d(n, "class", "a9s-touch-halo svelte-1sgkh33"), ye(
        n,
        "touched",
        /*touched*/
        e[4]
      ), d(i, "class", s = Ke(`a9s-handle ${/*$$props*/
      e[8].class || ""}`.trim()) + " svelte-1sgkh33"), d(i, "x", r = /*x*/
      e[0] - /*handleSize*/
      e[5] / 2), d(i, "y", l = /*y*/
      e[1] - /*handleSize*/
      e[5] / 2), d(
        i,
        "width",
        /*handleSize*/
        e[5]
      ), d(
        i,
        "height",
        /*handleSize*/
        e[5]
      ), d(t, "class", "a9s-touch-handle");
    },
    m(u, f) {
      B(u, t, f), he(t, n), he(t, i), a || (c = [
        z(
          n,
          "pointerdown",
          /*pointerdown_handler*/
          e[10]
        ),
        z(
          n,
          "pointerdown",
          /*onPointerDown*/
          e[6]
        ),
        z(
          n,
          "pointerup",
          /*onPointerUp*/
          e[7]
        ),
        z(
          i,
          "pointerdown",
          /*pointerdown_handler_1*/
          e[9]
        ),
        z(
          i,
          "pointerdown",
          /*onPointerDown*/
          e[6]
        ),
        z(
          i,
          "pointerup",
          /*onPointerUp*/
          e[7]
        )
      ], a = !0);
    },
    p(u, f) {
      f & /*x*/
      1 && d(
        n,
        "cx",
        /*x*/
        u[0]
      ), f & /*y*/
      2 && d(
        n,
        "cy",
        /*y*/
        u[1]
      ), f & /*radius, scale*/
      12 && o !== (o = /*radius*/
      u[3] / /*scale*/
      u[2]) && d(n, "r", o), f & /*touched*/
      16 && ye(
        n,
        "touched",
        /*touched*/
        u[4]
      ), f & /*$$props*/
      256 && s !== (s = Ke(`a9s-handle ${/*$$props*/
      u[8].class || ""}`.trim()) + " svelte-1sgkh33") && d(i, "class", s), f & /*x, handleSize*/
      33 && r !== (r = /*x*/
      u[0] - /*handleSize*/
      u[5] / 2) && d(i, "x", r), f & /*y, handleSize*/
      34 && l !== (l = /*y*/
      u[1] - /*handleSize*/
      u[5] / 2) && d(i, "y", l), f & /*handleSize*/
      32 && d(
        i,
        "width",
        /*handleSize*/
        u[5]
      ), f & /*handleSize*/
      32 && d(
        i,
        "height",
        /*handleSize*/
        u[5]
      );
    },
    d(u) {
      u && I(t), a = !1, ge(c);
    }
  };
}
function Xo(e) {
  let t;
  function n(s, r) {
    return Yo ? Co : Po;
  }
  let i = n()(e);
  return {
    c() {
      i.c(), t = ae();
    },
    m(s, r) {
      i.m(s, r), B(s, t, r);
    },
    p(s, [r]) {
      i.p(s, r);
    },
    i: j,
    o: j,
    d(s) {
      s && I(t), i.d(s);
    }
  };
}
function Uo(e, t, n) {
  let o, { x: i } = t, { y: s } = t, { scale: r } = t, { radius: l = 30 } = t, a = !1;
  const c = (g) => {
    g.pointerType === "touch" && n(4, a = !0);
  }, u = () => n(4, a = !1);
  function f(g) {
    me.call(this, e, g);
  }
  function h(g) {
    me.call(this, e, g);
  }
  function y(g) {
    me.call(this, e, g);
  }
  return e.$$set = (g) => {
    n(8, t = ft(ft({}, t), bt(g))), "x" in g && n(0, i = g.x), "y" in g && n(1, s = g.y), "scale" in g && n(2, r = g.scale), "radius" in g && n(3, l = g.radius);
  }, e.$$.update = () => {
    e.$$.dirty & /*scale*/
    4 && n(5, o = 10 / r);
  }, t = bt(t), [
    i,
    s,
    r,
    l,
    a,
    o,
    c,
    u,
    t,
    f,
    h,
    y
  ];
}
class Pe extends ie {
  constructor(t) {
    super(), oe(this, t, Uo, Xo, Q, { x: 0, y: 1, scale: 2, radius: 3 });
  }
}
function Ro(e) {
  let t, n, o, i, s, r, l, a, c, u, f, h, y, g, m, A, p, _, w, E, k, X, R, V, Z, S, v, b, T, Y, D, H, J, $, pe, ce, Be, fe, Oe, ue, U, De, Ve;
  return $ = new Pe({
    props: {
      class: "a9s-corner-handle-topleft",
      x: (
        /*geom*/
        e[4].x
      ),
      y: (
        /*geom*/
        e[4].y
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), $.$on("pointerdown", function() {
    K(
      /*grab*/
      e[9]("TOP_LEFT")
    ) && e[9]("TOP_LEFT").apply(this, arguments);
  }), ce = new Pe({
    props: {
      class: "a9s-corner-handle-topright",
      x: (
        /*geom*/
        e[4].x + /*geom*/
        e[4].w
      ),
      y: (
        /*geom*/
        e[4].y
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), ce.$on("pointerdown", function() {
    K(
      /*grab*/
      e[9]("TOP_RIGHT")
    ) && e[9]("TOP_RIGHT").apply(this, arguments);
  }), fe = new Pe({
    props: {
      class: "a9s-corner-handle-bottomright",
      x: (
        /*geom*/
        e[4].x + /*geom*/
        e[4].w
      ),
      y: (
        /*geom*/
        e[4].y + /*geom*/
        e[4].h
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), fe.$on("pointerdown", function() {
    K(
      /*grab*/
      e[9]("BOTTOM_RIGHT")
    ) && e[9]("BOTTOM_RIGHT").apply(this, arguments);
  }), ue = new Pe({
    props: {
      class: "a9s-corner-handle-bottomleft",
      x: (
        /*geom*/
        e[4].x
      ),
      y: (
        /*geom*/
        e[4].y + /*geom*/
        e[4].h
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), ue.$on("pointerdown", function() {
    K(
      /*grab*/
      e[9]("BOTTOM_LEFT")
    ) && e[9]("BOTTOM_LEFT").apply(this, arguments);
  }), {
    c() {
      t = C("rect"), l = se(), a = C("rect"), y = se(), g = C("rect"), _ = se(), w = C("rect"), R = se(), V = C("rect"), b = se(), T = C("rect"), J = se(), ne($.$$.fragment), pe = se(), ne(ce.$$.fragment), Be = se(), ne(fe.$$.fragment), Oe = se(), ne(ue.$$.fragment), d(t, "class", "a9s-outer"), d(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), d(t, "x", o = /*geom*/
      e[4].x), d(t, "y", i = /*geom*/
      e[4].y), d(t, "width", s = /*geom*/
      e[4].w), d(t, "height", r = /*geom*/
      e[4].h), d(a, "class", "a9s-inner a9s-shape-handle"), d(
        a,
        "style",
        /*computedStyle*/
        e[1]
      ), d(a, "x", c = /*geom*/
      e[4].x), d(a, "y", u = /*geom*/
      e[4].y), d(a, "width", f = /*geom*/
      e[4].w), d(a, "height", h = /*geom*/
      e[4].h), d(g, "class", "a9s-edge-handle a9s-edge-handle-top"), d(g, "x", m = /*geom*/
      e[4].x), d(g, "y", A = /*geom*/
      e[4].y), d(g, "height", 1), d(g, "width", p = /*geom*/
      e[4].w), d(w, "class", "a9s-edge-handle a9s-edge-handle-right"), d(w, "x", E = /*geom*/
      e[4].x + /*geom*/
      e[4].w), d(w, "y", k = /*geom*/
      e[4].y), d(w, "height", X = /*geom*/
      e[4].h), d(w, "width", 1), d(V, "class", "a9s-edge-handle a9s-edge-handle-bottom"), d(V, "x", Z = /*geom*/
      e[4].x), d(V, "y", S = /*geom*/
      e[4].y + /*geom*/
      e[4].h), d(V, "height", 1), d(V, "width", v = /*geom*/
      e[4].w), d(T, "class", "a9s-edge-handle a9s-edge-handle-left"), d(T, "x", Y = /*geom*/
      e[4].x), d(T, "y", D = /*geom*/
      e[4].y), d(T, "height", H = /*geom*/
      e[4].h), d(T, "width", 1);
    },
    m(M, L) {
      B(M, t, L), B(M, l, L), B(M, a, L), B(M, y, L), B(M, g, L), B(M, _, L), B(M, w, L), B(M, R, L), B(M, V, L), B(M, b, L), B(M, T, L), B(M, J, L), ee($, M, L), B(M, pe, L), ee(ce, M, L), B(M, Be, L), ee(fe, M, L), B(M, Oe, L), ee(ue, M, L), U = !0, De || (Ve = [
        z(t, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        }),
        z(a, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("SHAPE")
          ) && e[9]("SHAPE").apply(this, arguments);
        }),
        z(g, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("TOP")
          ) && e[9]("TOP").apply(this, arguments);
        }),
        z(w, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("RIGHT")
          ) && e[9]("RIGHT").apply(this, arguments);
        }),
        z(V, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("BOTTOM")
          ) && e[9]("BOTTOM").apply(this, arguments);
        }),
        z(T, "pointerdown", function() {
          K(
            /*grab*/
            e[9]("LEFT")
          ) && e[9]("LEFT").apply(this, arguments);
        })
      ], De = !0);
    },
    p(M, L) {
      e = M, (!U || L & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      e[1] ? "display:none;" : void 0)) && d(t, "style", n), (!U || L & /*geom*/
      16 && o !== (o = /*geom*/
      e[4].x)) && d(t, "x", o), (!U || L & /*geom*/
      16 && i !== (i = /*geom*/
      e[4].y)) && d(t, "y", i), (!U || L & /*geom*/
      16 && s !== (s = /*geom*/
      e[4].w)) && d(t, "width", s), (!U || L & /*geom*/
      16 && r !== (r = /*geom*/
      e[4].h)) && d(t, "height", r), (!U || L & /*computedStyle*/
      2) && d(
        a,
        "style",
        /*computedStyle*/
        e[1]
      ), (!U || L & /*geom*/
      16 && c !== (c = /*geom*/
      e[4].x)) && d(a, "x", c), (!U || L & /*geom*/
      16 && u !== (u = /*geom*/
      e[4].y)) && d(a, "y", u), (!U || L & /*geom*/
      16 && f !== (f = /*geom*/
      e[4].w)) && d(a, "width", f), (!U || L & /*geom*/
      16 && h !== (h = /*geom*/
      e[4].h)) && d(a, "height", h), (!U || L & /*geom*/
      16 && m !== (m = /*geom*/
      e[4].x)) && d(g, "x", m), (!U || L & /*geom*/
      16 && A !== (A = /*geom*/
      e[4].y)) && d(g, "y", A), (!U || L & /*geom*/
      16 && p !== (p = /*geom*/
      e[4].w)) && d(g, "width", p), (!U || L & /*geom*/
      16 && E !== (E = /*geom*/
      e[4].x + /*geom*/
      e[4].w)) && d(w, "x", E), (!U || L & /*geom*/
      16 && k !== (k = /*geom*/
      e[4].y)) && d(w, "y", k), (!U || L & /*geom*/
      16 && X !== (X = /*geom*/
      e[4].h)) && d(w, "height", X), (!U || L & /*geom*/
      16 && Z !== (Z = /*geom*/
      e[4].x)) && d(V, "x", Z), (!U || L & /*geom*/
      16 && S !== (S = /*geom*/
      e[4].y + /*geom*/
      e[4].h)) && d(V, "y", S), (!U || L & /*geom*/
      16 && v !== (v = /*geom*/
      e[4].w)) && d(V, "width", v), (!U || L & /*geom*/
      16 && Y !== (Y = /*geom*/
      e[4].x)) && d(T, "x", Y), (!U || L & /*geom*/
      16 && D !== (D = /*geom*/
      e[4].y)) && d(T, "y", D), (!U || L & /*geom*/
      16 && H !== (H = /*geom*/
      e[4].h)) && d(T, "height", H);
      const N = {};
      L & /*geom*/
      16 && (N.x = /*geom*/
      e[4].x), L & /*geom*/
      16 && (N.y = /*geom*/
      e[4].y), L & /*viewportScale*/
      8 && (N.scale = /*viewportScale*/
      e[3]), $.$set(N);
      const x = {};
      L & /*geom*/
      16 && (x.x = /*geom*/
      e[4].x + /*geom*/
      e[4].w), L & /*geom*/
      16 && (x.y = /*geom*/
      e[4].y), L & /*viewportScale*/
      8 && (x.scale = /*viewportScale*/
      e[3]), ce.$set(x);
      const de = {};
      L & /*geom*/
      16 && (de.x = /*geom*/
      e[4].x + /*geom*/
      e[4].w), L & /*geom*/
      16 && (de.y = /*geom*/
      e[4].y + /*geom*/
      e[4].h), L & /*viewportScale*/
      8 && (de.scale = /*viewportScale*/
      e[3]), fe.$set(de);
      const we = {};
      L & /*geom*/
      16 && (we.x = /*geom*/
      e[4].x), L & /*geom*/
      16 && (we.y = /*geom*/
      e[4].y + /*geom*/
      e[4].h), L & /*viewportScale*/
      8 && (we.scale = /*viewportScale*/
      e[3]), ue.$set(we);
    },
    i(M) {
      U || (O($.$$.fragment, M), O(ce.$$.fragment, M), O(fe.$$.fragment, M), O(ue.$$.fragment, M), U = !0);
    },
    o(M) {
      P($.$$.fragment, M), P(ce.$$.fragment, M), P(fe.$$.fragment, M), P(ue.$$.fragment, M), U = !1;
    },
    d(M) {
      M && (I(t), I(l), I(a), I(y), I(g), I(_), I(w), I(R), I(V), I(b), I(T), I(J), I(pe), I(Be), I(Oe)), te($, M), te(ce, M), te(fe, M), te(ue, M), De = !1, ge(Ve);
    }
  };
}
function No(e) {
  let t, n;
  return t = new an({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[5]
      ),
      $$slots: {
        default: [
          Ro,
          ({ grab: o }) => ({ 9: o }),
          ({ grab: o }) => o ? 512 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "grab",
    /*grab_handler*/
    e[6]
  ), t.$on(
    "change",
    /*change_handler*/
    e[7]
  ), t.$on(
    "release",
    /*release_handler*/
    e[8]
  ), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, [i]) {
      const s = {};
      i & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i & /*$$scope, geom, viewportScale, grab, computedStyle*/
      1562 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
function Vo(e, t, n) {
  let o, { shape: i } = t, { computedStyle: s } = t, { transform: r } = t, { viewportScale: l = 1 } = t;
  const a = (h, y, g) => {
    const m = h.geometry.bounds;
    let [A, p] = [m.minX, m.minY], [_, w] = [m.maxX, m.maxY];
    const [E, k] = g;
    if (y === "SHAPE")
      A += E, _ += E, p += k, w += k;
    else {
      switch (y) {
        case "TOP":
        case "TOP_LEFT":
        case "TOP_RIGHT": {
          p += k;
          break;
        }
        case "BOTTOM":
        case "BOTTOM_LEFT":
        case "BOTTOM_RIGHT": {
          w += k;
          break;
        }
      }
      switch (y) {
        case "LEFT":
        case "TOP_LEFT":
        case "BOTTOM_LEFT": {
          A += E;
          break;
        }
        case "RIGHT":
        case "TOP_RIGHT":
        case "BOTTOM_RIGHT": {
          _ += E;
          break;
        }
      }
    }
    const X = Math.min(A, _), R = Math.min(p, w), V = Math.abs(_ - A), Z = Math.abs(w - p);
    return {
      ...h,
      geometry: {
        x: X,
        y: R,
        w: V,
        h: Z,
        bounds: {
          minX: X,
          minY: R,
          maxX: X + V,
          maxY: R + Z
        }
      }
    };
  };
  function c(h) {
    me.call(this, e, h);
  }
  function u(h) {
    me.call(this, e, h);
  }
  function f(h) {
    me.call(this, e, h);
  }
  return e.$$set = (h) => {
    "shape" in h && n(0, i = h.shape), "computedStyle" in h && n(1, s = h.computedStyle), "transform" in h && n(2, r = h.transform), "viewportScale" in h && n(3, l = h.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(4, o = i.geometry);
  }, [
    i,
    s,
    r,
    l,
    o,
    a,
    c,
    u,
    f
  ];
}
class Go extends ie {
  constructor(t) {
    super(), oe(this, t, Vo, No, Q, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 3
    });
  }
}
const ln = /* @__PURE__ */ new Map([
  [F.RECTANGLE, Go],
  [F.POLYGON, Io]
]), jo = (e) => ln.get(e.type), zo = (e, t) => ln.set(e, t), Ho = (e) => ({}), Ot = (e) => ({ grab: (
  /*onGrab*/
  e[0]
) });
function Fo(e) {
  let t, n, o, i;
  const s = (
    /*#slots*/
    e[7].default
  ), r = pn(
    s,
    e,
    /*$$scope*/
    e[6],
    Ot
  );
  return {
    c() {
      t = C("g"), r && r.c(), d(t, "class", "a9s-annotation selected");
    },
    m(l, a) {
      B(l, t, a), r && r.m(t, null), n = !0, o || (i = [
        z(
          t,
          "pointerup",
          /*onRelease*/
          e[2]
        ),
        z(
          t,
          "pointermove",
          /*onPointerMove*/
          e[1]
        )
      ], o = !0);
    },
    p(l, [a]) {
      r && r.p && (!n || a & /*$$scope*/
      64) && _n(
        r,
        s,
        l,
        /*$$scope*/
        l[6],
        n ? yn(
          s,
          /*$$scope*/
          l[6],
          a,
          Ho
        ) : wn(
          /*$$scope*/
          l[6]
        ),
        Ot
      );
    },
    i(l) {
      n || (O(r, l), n = !0);
    },
    o(l) {
      P(r, l), n = !1;
    },
    d(l) {
      l && I(t), r && r.d(l), o = !1, ge(i);
    }
  };
}
function Ko(e, t, n) {
  let { $$slots: o = {}, $$scope: i } = t;
  const s = Ie();
  let { shape: r } = t, { editor: l } = t, { transform: a } = t, c, u, f;
  const h = (m) => (A) => {
    c = m, u = a.elementToImage(A.offsetX, A.offsetY), f = r, A.target.setPointerCapture(A.pointerId), s("grab", A);
  }, y = (m) => {
    if (c) {
      const [A, p] = a.elementToImage(m.offsetX, m.offsetY), _ = [A - u[0], p - u[1]];
      n(3, r = l(f, c, _)), s("change", r);
    }
  }, g = (m) => {
    m.target.releasePointerCapture(m.pointerId), c = void 0, f = r, s("release", m);
  };
  return e.$$set = (m) => {
    "shape" in m && n(3, r = m.shape), "editor" in m && n(4, l = m.editor), "transform" in m && n(5, a = m.transform), "$$scope" in m && n(6, i = m.$$scope);
  }, [h, y, g, r, l, a, i, o];
}
class an extends ie {
  constructor(t) {
    super(), oe(this, t, Ko, Fo, Q, { shape: 3, editor: 4, transform: 5 });
  }
}
const Qe = (e, t) => {
  const n = typeof t == "function" ? t(e) : t;
  if (n) {
    const { fill: o, fillOpacity: i, stroke: s, strokeWidth: r, strokeOpacity: l } = n;
    let a = "";
    return o && (a += `fill:${o};`, a += `fill-opacity:${i || "0.25"};`), s && (a += `stroke:${s};`, a += `stroke-width:${r || "1"};`, a += `stroke-opacity:${l || "1"};`), a;
  }
};
function Wo(e, t, n) {
  let o;
  const i = Ie();
  let { annotation: s } = t, { editor: r } = t, { style: l } = t, { target: a } = t, { transform: c } = t, { viewportScale: u } = t, f;
  return Ne(() => (n(6, f = new r({
    target: a,
    props: {
      shape: s.target.selector,
      computedStyle: o,
      transform: c,
      viewportScale: u
    }
  })), f.$on("change", (h) => {
    f.$$set({ shape: h.detail }), i("change", h.detail);
  }), f.$on("grab", (h) => i("grab", h.detail)), f.$on("release", (h) => i("release", h.detail)), () => {
    f.$destroy();
  })), e.$$set = (h) => {
    "annotation" in h && n(0, s = h.annotation), "editor" in h && n(1, r = h.editor), "style" in h && n(2, l = h.style), "target" in h && n(3, a = h.target), "transform" in h && n(4, c = h.transform), "viewportScale" in h && n(5, u = h.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    5 && n(7, o = Qe(s, l)), e.$$.dirty & /*annotation, editorComponent*/
    65 && s && (f == null || f.$set({ shape: s.target.selector })), e.$$.dirty & /*editorComponent, transform*/
    80 && f && f.$set({ transform: c }), e.$$.dirty & /*editorComponent, viewportScale*/
    96 && f && f.$set({ viewportScale: u }), e.$$.dirty & /*editorComponent, computedStyle*/
    192 && f && o && f.$set({ computedStyle: o });
  }, [
    s,
    r,
    l,
    a,
    c,
    u,
    f,
    o
  ];
}
class qo extends ie {
  constructor(t) {
    super(), oe(this, t, Wo, null, Q, {
      annotation: 0,
      editor: 1,
      style: 2,
      target: 3,
      transform: 4,
      viewportScale: 5
    });
  }
}
function Jo(e, t, n) {
  const o = Ie();
  let { drawingMode: i } = t, { target: s } = t, { tool: r } = t, { transform: l } = t, { viewportScale: a } = t, c;
  return Ne(() => {
    const u = s.closest("svg"), f = [], h = (y, g, m) => {
      u == null || u.addEventListener(y, g, m), f.push(() => u == null ? void 0 : u.removeEventListener(y, g, m));
    };
    return n(5, c = new r({
      target: s,
      props: {
        addEventListener: h,
        drawingMode: i,
        transform: l,
        viewportScale: a
      }
    })), c.$on("create", (y) => o("create", y.detail)), () => {
      f.forEach((y) => y()), c.$destroy();
    };
  }), e.$$set = (u) => {
    "drawingMode" in u && n(0, i = u.drawingMode), "target" in u && n(1, s = u.target), "tool" in u && n(2, r = u.tool), "transform" in u && n(3, l = u.transform), "viewportScale" in u && n(4, a = u.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*toolComponent, transform*/
    40 && c && c.$set({ transform: l }), e.$$.dirty & /*toolComponent, viewportScale*/
    48 && c && c.$set({ viewportScale: a });
  }, [i, s, r, l, a, c];
}
class Qo extends ie {
  constructor(t) {
    super(), oe(this, t, Jo, null, Q, {
      drawingMode: 0,
      target: 1,
      tool: 2,
      transform: 3,
      viewportScale: 4
    });
  }
}
function Dt(e) {
  let t, n;
  return {
    c() {
      t = C("rect"), n = C("rect"), d(t, "class", "a9s-outer"), d(
        t,
        "x",
        /*x*/
        e[1]
      ), d(
        t,
        "y",
        /*y*/
        e[2]
      ), d(
        t,
        "width",
        /*w*/
        e[3]
      ), d(
        t,
        "height",
        /*h*/
        e[4]
      ), d(n, "class", "a9s-inner"), d(
        n,
        "x",
        /*x*/
        e[1]
      ), d(
        n,
        "y",
        /*y*/
        e[2]
      ), d(
        n,
        "width",
        /*w*/
        e[3]
      ), d(
        n,
        "height",
        /*h*/
        e[4]
      );
    },
    m(o, i) {
      B(o, t, i), B(o, n, i);
    },
    p(o, i) {
      i & /*x*/
      2 && d(
        t,
        "x",
        /*x*/
        o[1]
      ), i & /*y*/
      4 && d(
        t,
        "y",
        /*y*/
        o[2]
      ), i & /*w*/
      8 && d(
        t,
        "width",
        /*w*/
        o[3]
      ), i & /*h*/
      16 && d(
        t,
        "height",
        /*h*/
        o[4]
      ), i & /*x*/
      2 && d(
        n,
        "x",
        /*x*/
        o[1]
      ), i & /*y*/
      4 && d(
        n,
        "y",
        /*y*/
        o[2]
      ), i & /*w*/
      8 && d(
        n,
        "width",
        /*w*/
        o[3]
      ), i & /*h*/
      16 && d(
        n,
        "height",
        /*h*/
        o[4]
      );
    },
    d(o) {
      o && (I(t), I(n));
    }
  };
}
function Zo(e) {
  let t, n = (
    /*origin*/
    e[0] && Dt(e)
  );
  return {
    c() {
      t = C("g"), n && n.c(), d(t, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, i) {
      B(o, t, i), n && n.m(t, null);
    },
    p(o, [i]) {
      /*origin*/
      o[0] ? n ? n.p(o, i) : (n = Dt(o), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    i: j,
    o: j,
    d(o) {
      o && I(t), n && n.d();
    }
  };
}
function xo(e, t, n) {
  const o = Ie();
  let { addEventListener: i } = t, { drawingMode: s } = t, { transform: r } = t, l, a, c, u, f, h, y;
  const g = (_) => {
    const w = _;
    l = performance.now(), s === "drag" && (n(0, a = r.elementToImage(w.offsetX, w.offsetY)), c = a, n(1, u = a[0]), n(2, f = a[1]), n(3, h = 1), n(4, y = 1));
  }, m = (_) => {
    const w = _;
    a && (c = r.elementToImage(w.offsetX, w.offsetY), n(1, u = Math.min(c[0], a[0])), n(2, f = Math.min(c[1], a[1])), n(3, h = Math.abs(c[0] - a[0])), n(4, y = Math.abs(c[1] - a[1])));
  }, A = (_) => {
    const w = _, E = performance.now() - l;
    if (s === "click") {
      if (E > 300) return;
      a ? p() : (n(0, a = r.elementToImage(w.offsetX, w.offsetY)), c = a, n(1, u = a[0]), n(2, f = a[1]), n(3, h = 1), n(4, y = 1));
    } else a && (E > 300 || h * y > 100 ? (w.stopPropagation(), p()) : (n(0, a = void 0), c = void 0));
  }, p = () => {
    if (h * y > 15) {
      const _ = {
        type: F.RECTANGLE,
        geometry: {
          bounds: {
            minX: u,
            minY: f,
            maxX: u + h,
            maxY: f + y
          },
          x: u,
          y: f,
          w: h,
          h: y
        }
      };
      o("create", _);
    }
    n(0, a = void 0), c = void 0;
  };
  return Ne(() => {
    i("pointerdown", g), i("pointermove", m), i("pointerup", A, !0);
  }), e.$$set = (_) => {
    "addEventListener" in _ && n(5, i = _.addEventListener), "drawingMode" in _ && n(6, s = _.drawingMode), "transform" in _ && n(7, r = _.transform);
  }, [a, u, f, h, y, i, s, r];
}
class $o extends ie {
  constructor(t) {
    super(), oe(this, t, xo, Zo, Q, {
      addEventListener: 5,
      drawingMode: 6,
      transform: 7
    });
  }
}
function rt(e) {
  const t = e.slice(), n = (
    /*isClosable*/
    (t[2] ? (
      /*points*/
      t[0]
    ) : [
      .../*points*/
      t[0],
      /*cursor*/
      t[1]
    ]).map((o) => o.join(",")).join(" ")
  );
  return t[16] = n, t;
}
function Yt(e) {
  let t, n, o, i, s, r = (
    /*isClosable*/
    e[2] && Pt(e)
  );
  return {
    c() {
      t = C("polygon"), o = C("polygon"), r && r.c(), s = ae(), d(t, "class", "a9s-outer"), d(t, "points", n = /*coords*/
      e[16]), d(o, "class", "a9s-inner"), d(o, "points", i = /*coords*/
      e[16]);
    },
    m(l, a) {
      B(l, t, a), B(l, o, a), r && r.m(l, a), B(l, s, a);
    },
    p(l, a) {
      a & /*isClosable, points, cursor*/
      7 && n !== (n = /*coords*/
      l[16]) && d(t, "points", n), a & /*isClosable, points, cursor*/
      7 && i !== (i = /*coords*/
      l[16]) && d(o, "points", i), /*isClosable*/
      l[2] ? r ? r.p(l, a) : (r = Pt(l), r.c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null);
    },
    d(l) {
      l && (I(t), I(o), I(s)), r && r.d(l);
    }
  };
}
function Pt(e) {
  let t, n, o;
  return {
    c() {
      t = C("rect"), d(t, "class", "a9s-handle"), d(t, "x", n = /*points*/
      e[0][0][0] - /*handleSize*/
      e[3] / 2), d(t, "y", o = /*points*/
      e[0][0][1] - /*handleSize*/
      e[3] / 2), d(
        t,
        "height",
        /*handleSize*/
        e[3]
      ), d(
        t,
        "width",
        /*handleSize*/
        e[3]
      );
    },
    m(i, s) {
      B(i, t, s);
    },
    p(i, s) {
      s & /*points, handleSize*/
      9 && n !== (n = /*points*/
      i[0][0][0] - /*handleSize*/
      i[3] / 2) && d(t, "x", n), s & /*points, handleSize*/
      9 && o !== (o = /*points*/
      i[0][0][1] - /*handleSize*/
      i[3] / 2) && d(t, "y", o), s & /*handleSize*/
      8 && d(
        t,
        "height",
        /*handleSize*/
        i[3]
      ), s & /*handleSize*/
      8 && d(
        t,
        "width",
        /*handleSize*/
        i[3]
      );
    },
    d(i) {
      i && I(t);
    }
  };
}
function ei(e) {
  let t, n = (
    /*cursor*/
    e[1] && Yt(rt(e))
  );
  return {
    c() {
      t = C("g"), n && n.c(), d(t, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, i) {
      B(o, t, i), n && n.m(t, null);
    },
    p(o, [i]) {
      /*cursor*/
      o[1] ? n ? n.p(rt(o), i) : (n = Yt(rt(o)), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    i: j,
    o: j,
    d(o) {
      o && I(t), n && n.d();
    }
  };
}
const ti = 20, ni = 1500;
function oi(e, t, n) {
  let o;
  const i = Ie();
  let { addEventListener: s } = t, { drawingMode: r } = t, { transform: l } = t, { viewportScale: a = 1 } = t, c, u = [], f, h, y = !1;
  const g = (w) => {
    const E = w, { timeStamp: k, offsetX: X, offsetY: R } = E;
    if (c = { timeStamp: k, offsetX: X, offsetY: R }, r === "drag" && u.length === 0) {
      const V = l.elementToImage(E.offsetX, E.offsetY);
      u.push(V), n(1, f = V);
    }
  }, m = (w) => {
    const E = w;
    if (h && clearTimeout(h), u.length > 0) {
      if (n(1, f = l.elementToImage(E.offsetX, E.offsetY)), u.length > 2) {
        const k = st(f, u[0]) * a;
        n(2, y = k < ti);
      }
      E.pointerType === "touch" && (h = setTimeout(
        () => {
          p();
        },
        ni
      ));
    }
  }, A = (w) => {
    const E = w;
    if (h && clearTimeout(h), r === "click") {
      const k = E.timeStamp - c.timeStamp, X = st([c.offsetX, c.offsetY], [E.offsetX, E.offsetY]);
      if (k > 300 || X > 15) return;
      if (y)
        _();
      else if (u.length === 0) {
        const R = l.elementToImage(E.offsetX, E.offsetY);
        u.push(R), n(1, f = R);
      } else
        u.push(f);
    } else {
      if (u.length === 1 && st(u[0], f) <= 4) {
        n(0, u = []), n(1, f = void 0);
        return;
      }
      E.stopImmediatePropagation(), y ? _() : u.push(f);
    }
  }, p = () => {
    if (!f) return;
    const w = [...u, f], E = {
      type: F.POLYGON,
      geometry: { bounds: qe(w), points: w }
    };
    ht(E) > 4 && (n(0, u = []), n(1, f = void 0), i("create", E));
  }, _ = () => {
    const w = {
      type: F.POLYGON,
      geometry: {
        bounds: qe(u),
        points: [...u]
      }
    };
    n(0, u = []), n(1, f = void 0), i("create", w);
  };
  return Ne(() => {
    s("pointerdown", g, !0), s("pointermove", m), s("pointerup", A, !0), s("dblclick", p, !0);
  }), e.$$set = (w) => {
    "addEventListener" in w && n(4, s = w.addEventListener), "drawingMode" in w && n(5, r = w.drawingMode), "transform" in w && n(6, l = w.transform), "viewportScale" in w && n(7, a = w.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*viewportScale*/
    128 && n(3, o = 10 / a);
  }, [
    u,
    f,
    y,
    o,
    s,
    r,
    l,
    a
  ];
}
class ii extends ie {
  constructor(t) {
    super(), oe(this, t, oi, ei, Q, {
      addEventListener: 4,
      drawingMode: 5,
      transform: 6,
      viewportScale: 7
    });
  }
}
const _t = /* @__PURE__ */ new Map([
  ["rectangle", { tool: $o }],
  ["polygon", { tool: ii }]
]), cn = () => [..._t.keys()], fn = (e) => _t.get(e), si = (e, t, n) => _t.set(e, { tool: t, opts: n });
function ri(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = C("g"), n = C("ellipse"), i = C("ellipse"), d(n, "class", "a9s-outer"), d(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), d(
        n,
        "cx",
        /*cx*/
        e[2]
      ), d(
        n,
        "cy",
        /*cy*/
        e[3]
      ), d(
        n,
        "rx",
        /*rx*/
        e[4]
      ), d(
        n,
        "ry",
        /*ry*/
        e[5]
      ), d(i, "class", "a9s-inner"), d(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), d(
        i,
        "cx",
        /*cx*/
        e[2]
      ), d(
        i,
        "cy",
        /*cy*/
        e[3]
      ), d(
        i,
        "rx",
        /*rx*/
        e[4]
      ), d(
        i,
        "ry",
        /*ry*/
        e[5]
      ), d(t, "class", "a9s-annotation"), d(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      B(r, t, l), he(t, n), he(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && d(n, "style", o), l & /*computedStyle*/
      2 && d(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && d(t, "data-id", s);
    },
    i: j,
    o: j,
    d(r) {
      r && I(t);
    }
  };
}
function li(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;
  const { cx: l, cy: a, rx: c, ry: u } = s;
  return e.$$set = (f) => {
    "annotation" in f && n(0, i = f.annotation), "geom" in f && n(6, s = f.geom), "style" in f && n(7, r = f.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(1, o = Qe(i, r));
  }, [i, o, l, a, c, u, s, r];
}
class ai extends ie {
  constructor(t) {
    super(), oe(this, t, li, ri, Q, { annotation: 0, geom: 6, style: 7 });
  }
}
function ci(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = C("g"), n = C("polygon"), i = C("polygon"), d(n, "class", "a9s-outer"), d(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), d(
        n,
        "points",
        /*points*/
        e[2].map(fi).join(" ")
      ), d(i, "class", "a9s-inner"), d(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), d(
        i,
        "points",
        /*points*/
        e[2].map(ui).join(" ")
      ), d(t, "class", "a9s-annotation"), d(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      B(r, t, l), he(t, n), he(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && d(n, "style", o), l & /*computedStyle*/
      2 && d(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && d(t, "data-id", s);
    },
    i: j,
    o: j,
    d(r) {
      r && I(t);
    }
  };
}
const fi = (e) => e.join(","), ui = (e) => e.join(",");
function di(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;
  const { points: l } = s;
  return e.$$set = (a) => {
    "annotation" in a && n(0, i = a.annotation), "geom" in a && n(3, s = a.geom), "style" in a && n(4, r = a.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    17 && n(1, o = Qe(i, r));
  }, [i, o, l, s, r];
}
class hi extends ie {
  constructor(t) {
    super(), oe(this, t, di, ci, Q, { annotation: 0, geom: 3, style: 4 });
  }
}
function gi(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = C("g"), n = C("rect"), i = C("rect"), d(n, "class", "a9s-outer"), d(n, "style", o = /*computedStyle*/
      e[5] ? "display:none;" : void 0), d(
        n,
        "x",
        /*x*/
        e[4]
      ), d(
        n,
        "y",
        /*y*/
        e[3]
      ), d(
        n,
        "width",
        /*w*/
        e[2]
      ), d(
        n,
        "height",
        /*h*/
        e[1]
      ), d(i, "class", "a9s-inner"), d(
        i,
        "style",
        /*computedStyle*/
        e[5]
      ), d(
        i,
        "x",
        /*x*/
        e[4]
      ), d(
        i,
        "y",
        /*y*/
        e[3]
      ), d(
        i,
        "width",
        /*w*/
        e[2]
      ), d(
        i,
        "height",
        /*h*/
        e[1]
      ), d(t, "class", "a9s-annotation"), d(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      B(r, t, l), he(t, n), he(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      32 && o !== (o = /*computedStyle*/
      r[5] ? "display:none;" : void 0) && d(n, "style", o), l & /*x*/
      16 && d(
        n,
        "x",
        /*x*/
        r[4]
      ), l & /*y*/
      8 && d(
        n,
        "y",
        /*y*/
        r[3]
      ), l & /*w*/
      4 && d(
        n,
        "width",
        /*w*/
        r[2]
      ), l & /*h*/
      2 && d(
        n,
        "height",
        /*h*/
        r[1]
      ), l & /*computedStyle*/
      32 && d(
        i,
        "style",
        /*computedStyle*/
        r[5]
      ), l & /*x*/
      16 && d(
        i,
        "x",
        /*x*/
        r[4]
      ), l & /*y*/
      8 && d(
        i,
        "y",
        /*y*/
        r[3]
      ), l & /*w*/
      4 && d(
        i,
        "width",
        /*w*/
        r[2]
      ), l & /*h*/
      2 && d(
        i,
        "height",
        /*h*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && d(t, "data-id", s);
    },
    i: j,
    o: j,
    d(r) {
      r && I(t);
    }
  };
}
function mi(e, t, n) {
  let o, i, s, r, l, { annotation: a } = t, { geom: c } = t, { style: u } = t;
  return e.$$set = (f) => {
    "annotation" in f && n(0, a = f.annotation), "geom" in f && n(6, c = f.geom), "style" in f && n(7, u = f.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(5, o = Qe(a, u)), e.$$.dirty & /*geom*/
    64 && n(4, { x: i, y: s, w: r, h: l } = c, i, (n(3, s), n(6, c)), (n(2, r), n(6, c)), (n(1, l), n(6, c)));
  }, [a, l, r, s, i, o, c, u];
}
class pi extends ie {
  constructor(t) {
    super(), oe(this, t, mi, gi, Q, { annotation: 0, geom: 6, style: 7 });
  }
}
const qi = {
  elementToImage: (e, t) => [e, t]
}, yi = (e) => ({
  elementToImage: (t, n) => {
    const o = e.getBoundingClientRect(), i = e.createSVGPoint();
    i.x = t + o.x, i.y = n + o.y;
    const { x: s, y: r } = i.matrixTransform(e.getScreenCTM().inverse());
    return [s, r];
  }
}), _i = 250, wi = (e, t) => {
  const n = Ie();
  let o;
  return { onPointerDown: () => o = performance.now(), onPointerUp: (r) => {
    if (performance.now() - o < _i) {
      const { x: a, y: c } = un(r, e), u = t.getAt(a, c);
      u ? n("click", { originalEvent: r, annotation: u }) : n("click", { originalEvent: r });
    }
  } };
}, un = (e, t) => {
  const n = t.createSVGPoint(), o = t.getBoundingClientRect(), i = e.clientX - o.x, s = e.clientY - o.y, { left: r, top: l } = t.getBoundingClientRect();
  return n.x = i + r, n.y = s + l, n.matrixTransform(t.getScreenCTM().inverse());
};
function Ct(e, t, n) {
  const o = e.slice();
  o[39] = t[n];
  const i = (
    /*getEditor*/
    o[24](
      /*editable*/
      o[39].target.selector
    )
  );
  return o[40] = i, o;
}
function Xt(e, t, n) {
  const o = e.slice();
  return o[43] = t[n], o;
}
function lt(e) {
  const t = e.slice(), n = (
    /*annotation*/
    t[43].target.selector
  );
  return t[46] = n, t;
}
function Ut(e) {
  let t = (
    /*annotation*/
    e[43].id
  ), n, o, i = Rt(e);
  return {
    c() {
      i.c(), n = ae();
    },
    m(s, r) {
      i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r[0] & /*$store*/
      65536 && Q(t, t = /*annotation*/
      s[43].id) ? (re(), P(i, 1, 1, j), le(), i = Rt(s), i.c(), O(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (O(i), o = !0);
    },
    o(s) {
      P(i), o = !1;
    },
    d(s) {
      s && I(n), i.d(s);
    }
  };
}
function bi(e) {
  let t, n;
  return t = new hi({
    props: {
      annotation: (
        /*annotation*/
        e[43]
      ),
      geom: (
        /*selector*/
        e[46].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      65536 && (s.annotation = /*annotation*/
      o[43]), i[0] & /*$store*/
      65536 && (s.geom = /*selector*/
      o[46].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
function Ei(e) {
  let t, n;
  return t = new pi({
    props: {
      annotation: (
        /*annotation*/
        e[43]
      ),
      geom: (
        /*selector*/
        e[46].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      65536 && (s.annotation = /*annotation*/
      o[43]), i[0] & /*$store*/
      65536 && (s.geom = /*selector*/
      o[46].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
function Ai(e) {
  var o;
  let t, n;
  return t = new ai({
    props: {
      annotation: (
        /*annotation*/
        e[43]
      ),
      geom: (
        /*selector*/
        (o = e[46]) == null ? void 0 : o.geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ne(t.$$.fragment);
    },
    m(i, s) {
      ee(t, i, s), n = !0;
    },
    p(i, s) {
      var l;
      const r = {};
      s[0] & /*$store*/
      65536 && (r.annotation = /*annotation*/
      i[43]), s[0] & /*$store*/
      65536 && (r.geom = /*selector*/
      (l = i[46]) == null ? void 0 : l.geometry), s[0] & /*style*/
      2 && (r.style = /*style*/
      i[1]), t.$set(r);
    },
    i(i) {
      n || (O(t.$$.fragment, i), n = !0);
    },
    o(i) {
      P(t.$$.fragment, i), n = !1;
    },
    d(i) {
      te(t, i);
    }
  };
}
function Rt(e) {
  let t, n, o, i;
  const s = [Ai, Ei, bi], r = [];
  function l(a, c) {
    var u, f, h;
    return (
      /*selector*/
      ((u = a[46]) == null ? void 0 : u.type) === F.ELLIPSE ? 0 : (
        /*selector*/
        ((f = a[46]) == null ? void 0 : f.type) === F.RECTANGLE ? 1 : (
          /*selector*/
          ((h = a[46]) == null ? void 0 : h.type) === F.POLYGON ? 2 : -1
        )
      )
    );
  }
  return ~(t = l(e)) && (n = r[t] = s[t](e)), {
    c() {
      n && n.c(), o = ae();
    },
    m(a, c) {
      ~t && r[t].m(a, c), B(a, o, c), i = !0;
    },
    p(a, c) {
      let u = t;
      t = l(a), t === u ? ~t && r[t].p(a, c) : (n && (re(), P(r[u], 1, 1, () => {
        r[u] = null;
      }), le()), ~t ? (n = r[t], n ? n.p(a, c) : (n = r[t] = s[t](a), n.c()), O(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(a) {
      i || (O(n), i = !0);
    },
    o(a) {
      P(n), i = !1;
    },
    d(a) {
      a && I(o), ~t && r[t].d(a);
    }
  };
}
function Nt(e) {
  let t = Je(
    /*annotation*/
    e[43]
  ) && !/*isEditable*/
  e[9](
    /*annotation*/
    e[43]
  ), n, o, i = t && Ut(lt(e));
  return {
    c() {
      i && i.c(), n = ae();
    },
    m(s, r) {
      i && i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r[0] & /*$store, isEditable*/
      66048 && (t = Je(
        /*annotation*/
        s[43]
      ) && !/*isEditable*/
      s[9](
        /*annotation*/
        s[43]
      )), t ? i ? (i.p(lt(s), r), r[0] & /*$store, isEditable*/
      66048 && O(i, 1)) : (i = Ut(lt(s)), i.c(), O(i, 1), i.m(n.parentNode, n)) : i && (re(), P(i, 1, 1, () => {
        i = null;
      }), le());
    },
    i(s) {
      o || (O(i), o = !0);
    },
    o(s) {
      P(i), o = !1;
    },
    d(s) {
      s && I(n), i && i.d(s);
    }
  };
}
function Vt(e) {
  let t, n, o, i;
  const s = [Ti, Si], r = [];
  function l(a, c) {
    return (
      /*editableAnnotations*/
      a[8] ? 0 : (
        /*tool*/
        a[14] && /*drawingEnabled*/
        a[0] ? 1 : -1
      )
    );
  }
  return ~(t = l(e)) && (n = r[t] = s[t](e)), {
    c() {
      n && n.c(), o = ae();
    },
    m(a, c) {
      ~t && r[t].m(a, c), B(a, o, c), i = !0;
    },
    p(a, c) {
      let u = t;
      t = l(a), t === u ? ~t && r[t].p(a, c) : (n && (re(), P(r[u], 1, 1, () => {
        r[u] = null;
      }), le()), ~t ? (n = r[t], n ? n.p(a, c) : (n = r[t] = s[t](a), n.c()), O(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(a) {
      i || (O(n), i = !0);
    },
    o(a) {
      P(n), i = !1;
    },
    d(a) {
      a && I(o), ~t && r[t].d(a);
    }
  };
}
function Si(e) {
  let t = `${/*toolName*/
  e[2]}-${/*toolMountKey*/
  e[5]}`, n, o, i = Gt(e);
  return {
    c() {
      i.c(), n = ae();
    },
    m(s, r) {
      i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r[0] & /*toolName, toolMountKey*/
      36 && Q(t, t = `${/*toolName*/
      s[2]}-${/*toolMountKey*/
      s[5]}`) ? (re(), P(i, 1, 1, j), le(), i = Gt(s), i.c(), O(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (O(i), o = !0);
    },
    o(s) {
      P(i), o = !1;
    },
    d(s) {
      s && I(n), i.d(s);
    }
  };
}
function Ti(e) {
  let t, n, o = ke(
    /*editableAnnotations*/
    e[8]
  ), i = [];
  for (let r = 0; r < o.length; r += 1)
    i[r] = Ht(Ct(e, o, r));
  const s = (r) => P(i[r], 1, 1, () => {
    i[r] = null;
  });
  return {
    c() {
      for (let r = 0; r < i.length; r += 1)
        i[r].c();
      t = ae();
    },
    m(r, l) {
      for (let a = 0; a < i.length; a += 1)
        i[a] && i[a].m(r, l);
      B(r, t, l), n = !0;
    },
    p(r, l) {
      if (l[0] & /*editableAnnotations, drawingEl, getEditor, style, transform, $scale, onChangeSelected*/
      21107010) {
        o = ke(
          /*editableAnnotations*/
          r[8]
        );
        let a;
        for (a = 0; a < o.length; a += 1) {
          const c = Ct(r, o, a);
          i[a] ? (i[a].p(c, l), O(i[a], 1)) : (i[a] = Ht(c), i[a].c(), O(i[a], 1), i[a].m(t.parentNode, t));
        }
        for (re(), a = o.length; a < i.length; a += 1)
          s(a);
        le();
      }
    },
    i(r) {
      if (!n) {
        for (let l = 0; l < o.length; l += 1)
          O(i[l]);
        n = !0;
      }
    },
    o(r) {
      i = i.filter(Boolean);
      for (let l = 0; l < i.length; l += 1)
        P(i[l]);
      n = !1;
    },
    d(r) {
      r && I(t), gt(i, r);
    }
  };
}
function Gt(e) {
  let t, n;
  return t = new Qo({
    props: {
      target: (
        /*drawingEl*/
        e[6]
      ),
      tool: (
        /*tool*/
        e[14]
      ),
      drawingMode: (
        /*drawingMode*/
        e[13]
      ),
      transform: (
        /*transform*/
        e[12]
      ),
      viewportScale: (
        /*$scale*/
        e[17]
      )
    }
  }), t.$on(
    "create",
    /*onSelectionCreated*/
    e[21]
  ), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i[0] & /*drawingEl*/
      64 && (s.target = /*drawingEl*/
      o[6]), i[0] & /*tool*/
      16384 && (s.tool = /*tool*/
      o[14]), i[0] & /*drawingMode*/
      8192 && (s.drawingMode = /*drawingMode*/
      o[13]), i[0] & /*transform*/
      4096 && (s.transform = /*transform*/
      o[12]), i[0] & /*$scale*/
      131072 && (s.viewportScale = /*$scale*/
      o[17]), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
function jt(e) {
  let t = (
    /*editable*/
    e[39].id
  ), n, o, i = zt(e);
  return {
    c() {
      i.c(), n = ae();
    },
    m(s, r) {
      i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r[0] & /*editableAnnotations*/
      256 && Q(t, t = /*editable*/
      s[39].id) ? (re(), P(i, 1, 1, j), le(), i = zt(s), i.c(), O(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (O(i), o = !0);
    },
    o(s) {
      P(i), o = !1;
    },
    d(s) {
      s && I(n), i.d(s);
    }
  };
}
function zt(e) {
  let t, n;
  return t = new qo({
    props: {
      target: (
        /*drawingEl*/
        e[6]
      ),
      editor: (
        /*getEditor*/
        e[24](
          /*editable*/
          e[39].target.selector
        )
      ),
      annotation: (
        /*editable*/
        e[39]
      ),
      style: (
        /*style*/
        e[1]
      ),
      transform: (
        /*transform*/
        e[12]
      ),
      viewportScale: (
        /*$scale*/
        e[17]
      )
    }
  }), t.$on("change", function() {
    K(
      /*onChangeSelected*/
      e[22](
        /*editable*/
        e[39]
      )
    ) && e[22](
      /*editable*/
      e[39]
    ).apply(this, arguments);
  }), {
    c() {
      ne(t.$$.fragment);
    },
    m(o, i) {
      ee(t, o, i), n = !0;
    },
    p(o, i) {
      e = o;
      const s = {};
      i[0] & /*drawingEl*/
      64 && (s.target = /*drawingEl*/
      e[6]), i[0] & /*editableAnnotations*/
      256 && (s.editor = /*getEditor*/
      e[24](
        /*editable*/
        e[39].target.selector
      )), i[0] & /*editableAnnotations*/
      256 && (s.annotation = /*editable*/
      e[39]), i[0] & /*style*/
      2 && (s.style = /*style*/
      e[1]), i[0] & /*transform*/
      4096 && (s.transform = /*transform*/
      e[12]), i[0] & /*$scale*/
      131072 && (s.viewportScale = /*$scale*/
      e[17]), t.$set(s);
    },
    i(o) {
      n || (O(t.$$.fragment, o), n = !0);
    },
    o(o) {
      P(t.$$.fragment, o), n = !1;
    },
    d(o) {
      te(t, o);
    }
  };
}
function Ht(e) {
  let t, n, o = (
    /*editor*/
    e[40] && jt(e)
  );
  return {
    c() {
      o && o.c(), t = ae();
    },
    m(i, s) {
      o && o.m(i, s), B(i, t, s), n = !0;
    },
    p(i, s) {
      /*editor*/
      i[40] ? o ? (o.p(i, s), s[0] & /*editableAnnotations*/
      256 && O(o, 1)) : (o = jt(i), o.c(), O(o, 1), o.m(t.parentNode, t)) : o && (re(), P(o, 1, 1, () => {
        o = null;
      }), le());
    },
    i(i) {
      n || (O(o), n = !0);
    },
    o(i) {
      P(o), n = !1;
    },
    d(i) {
      i && I(t), o && o.d(i);
    }
  };
}
function Mi(e) {
  let t, n, o, i, s, r, l = ke(
    /*$store*/
    e[16].filter(
      /*func*/
      e[34]
    )
  ), a = [];
  for (let f = 0; f < l.length; f += 1)
    a[f] = Nt(Xt(e, l, f));
  const c = (f) => P(a[f], 1, 1, () => {
    a[f] = null;
  });
  let u = (
    /*drawingEl*/
    e[6] && Vt(e)
  );
  return {
    c() {
      t = C("svg"), n = C("g");
      for (let f = 0; f < a.length; f += 1)
        a[f].c();
      o = C("g"), u && u.c(), d(o, "class", "drawing"), d(t, "class", "a9s-annotationlayer"), ye(
        t,
        "drawing",
        /*tool*/
        e[14]
      ), ye(t, "hidden", !/*visible*/
      e[3]), ye(
        t,
        "hover",
        /*$hover*/
        e[15]
      );
    },
    m(f, h) {
      B(f, t, h), he(t, n);
      for (let y = 0; y < a.length; y += 1)
        a[y] && a[y].m(n, null);
      he(t, o), u && u.m(o, null), e[35](o), e[36](t), i = !0, s || (r = [
        z(t, "pointerup", function() {
          K(
            /*onPointerUp*/
            e[10]
          ) && e[10].apply(this, arguments);
        }),
        z(t, "pointerdown", function() {
          K(
            /*onPointerDown*/
            e[11]
          ) && e[11].apply(this, arguments);
        }),
        z(
          t,
          "pointermove",
          /*onPointerMove*/
          e[23]
        )
      ], s = !0);
    },
    p(f, h) {
      if (e = f, h[0] & /*$store, style, isEditable*/
      66050) {
        l = ke(
          /*$store*/
          e[16].filter(
            /*func*/
            e[34]
          )
        );
        let y;
        for (y = 0; y < l.length; y += 1) {
          const g = Xt(e, l, y);
          a[y] ? (a[y].p(g, h), O(a[y], 1)) : (a[y] = Nt(g), a[y].c(), O(a[y], 1), a[y].m(n, null));
        }
        for (re(), y = l.length; y < a.length; y += 1)
          c(y);
        le();
      }
      /*drawingEl*/
      e[6] ? u ? (u.p(e, h), h[0] & /*drawingEl*/
      64 && O(u, 1)) : (u = Vt(e), u.c(), O(u, 1), u.m(o, null)) : u && (re(), P(u, 1, 1, () => {
        u = null;
      }), le()), (!i || h[0] & /*tool*/
      16384) && ye(
        t,
        "drawing",
        /*tool*/
        e[14]
      ), (!i || h[0] & /*visible*/
      8) && ye(t, "hidden", !/*visible*/
      e[3]), (!i || h[0] & /*$hover*/
      32768) && ye(
        t,
        "hover",
        /*$hover*/
        e[15]
      );
    },
    i(f) {
      if (!i) {
        for (let h = 0; h < l.length; h += 1)
          O(a[h]);
        O(u), i = !0;
      }
    },
    o(f) {
      a = a.filter(Boolean);
      for (let h = 0; h < a.length; h += 1)
        P(a[h]);
      P(u), i = !1;
    },
    d(f) {
      f && I(t), gt(a, f), u && u.d(), e[35](null), e[36](null), s = !1, ge(r);
    }
  };
}
function vi(e, t, n) {
  let o, i, s, r, l, a, c, u, f, h, y, g = j, m = () => (g(), g = Jt(Y, (M) => n(17, y = M)), Y);
  e.$$.on_destroy.push(() => g());
  let { drawingEnabled: A } = t, { image: p } = t, { preferredDrawingMode: _ } = t, { state: w } = t, { style: E = void 0 } = t, { toolName: k = cn()[0] } = t, { user: X } = t, { visible: R = !0 } = t, V = 0;
  const Z = () => n(5, V += 1), S = () => k, v = () => A;
  let b, T, Y;
  Ne(() => m(n(7, Y = Do(p, T))));
  const { hover: D, selection: H, store: J } = w;
  xe(e, D, (M) => n(15, u = M)), xe(e, H, (M) => n(33, f = M)), xe(e, J, (M) => n(16, h = M));
  let $, pe;
  const ce = (M) => {
    $ && J.unobserve($);
    const L = M.filter(({ editable: N }) => N).map(({ id: N }) => N);
    L.length > 0 ? (n(8, pe = L.map((N) => J.getAnnotation(N)).filter((N) => N && Je(N))), $ = (N) => {
      const { updated: x } = N.changes;
      n(8, pe = x == null ? void 0 : x.map((de) => de.newValue));
    }, J.observe($, { annotations: L })) : n(8, pe = void 0);
  }, Be = (M) => {
    const L = tn(), N = {
      id: L,
      bodies: [],
      target: {
        annotation: L,
        selector: M.detail,
        creator: X,
        created: /* @__PURE__ */ new Date()
      }
    };
    J.addAnnotation(N), H.setSelected(N.id);
  }, fe = (M) => (L) => {
    var we;
    const { target: N } = M, x = 10 * 60 * 1e3, de = ((we = N.creator) == null ? void 0 : we.id) !== X.id || !N.created || (/* @__PURE__ */ new Date()).getTime() - N.created.getTime() > x;
    J.updateTarget({
      ...N,
      selector: L.detail,
      created: de ? N.created : /* @__PURE__ */ new Date(),
      updated: de ? /* @__PURE__ */ new Date() : void 0,
      updatedBy: de ? X : void 0
    });
  }, Oe = (M) => {
    const { x: L, y: N } = un(M, T), x = J.getAt(L, N);
    x ? u !== x.id && D.set(x.id) : D.set(void 0);
  }, ue = (M) => jo(M), U = (M) => Je(M);
  function De(M) {
    We[M ? "unshift" : "push"](() => {
      b = M, n(6, b);
    });
  }
  function Ve(M) {
    We[M ? "unshift" : "push"](() => {
      T = M, n(4, T);
    });
  }
  return e.$$set = (M) => {
    "drawingEnabled" in M && n(0, A = M.drawingEnabled), "image" in M && n(25, p = M.image), "preferredDrawingMode" in M && n(26, _ = M.preferredDrawingMode), "state" in M && n(27, w = M.state), "style" in M && n(1, E = M.style), "toolName" in M && n(2, k = M.toolName), "user" in M && n(28, X = M.user), "visible" in M && n(3, R = M.visible);
  }, e.$$.update = () => {
    e.$$.dirty[0] & /*toolName*/
    4 && n(14, { tool: o, opts: i } = fn(k) || { tool: void 0, opts: void 0 }, o, (n(32, i), n(2, k))), e.$$.dirty[0] & /*preferredDrawingMode*/
    67108864 | e.$$.dirty[1] & /*opts*/
    2 && n(13, s = (i == null ? void 0 : i.drawingMode) || _), e.$$.dirty[0] & /*svgEl*/
    16 && n(12, r = yi(T)), e.$$.dirty[0] & /*svgEl*/
    16 && n(11, { onPointerDown: l, onPointerUp: a } = wi(T, J), l, (n(10, a), n(4, T))), e.$$.dirty[1] & /*$selection*/
    4 && n(9, c = (M) => f.selected.find((L) => L.id === M.id && L.editable)), e.$$.dirty[1] & /*$selection*/
    4 && ce(f.selected);
  }, [
    A,
    E,
    k,
    R,
    T,
    V,
    b,
    Y,
    pe,
    c,
    a,
    l,
    r,
    s,
    o,
    u,
    h,
    y,
    D,
    H,
    J,
    Be,
    fe,
    Oe,
    ue,
    p,
    _,
    w,
    X,
    Z,
    S,
    v,
    i,
    f,
    U,
    De,
    Ve
  ];
}
class Li extends ie {
  constructor(t) {
    super(), oe(
      this,
      t,
      vi,
      Mi,
      Q,
      {
        drawingEnabled: 0,
        image: 25,
        preferredDrawingMode: 26,
        state: 27,
        style: 1,
        toolName: 2,
        user: 28,
        visible: 3,
        cancelDrawing: 29,
        getDrawingTool: 30,
        isDrawingEnabled: 31
      },
      null,
      [-1, -1]
    );
  }
  get cancelDrawing() {
    return this.$$.ctx[29];
  }
  get getDrawingTool() {
    return this.$$.ctx[30];
  }
  get isDrawingEnabled() {
    return this.$$.ctx[31];
  }
}
function dn(e, t, n = 0, o = e.length - 1, i = ki) {
  for (; o > n; ) {
    if (o - n > 600) {
      const a = o - n + 1, c = t - n + 1, u = Math.log(a), f = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * f * (a - f) / a) * (c - a / 2 < 0 ? -1 : 1), y = Math.max(n, Math.floor(t - c * f / a + h)), g = Math.min(o, Math.floor(t + (a - c) * f / a + h));
      dn(e, t, y, g, i);
    }
    const s = e[t];
    let r = n, l = o;
    for (Ye(e, n, t), i(e[o], s) > 0 && Ye(e, n, o); r < l; ) {
      for (Ye(e, r, l), r++, l--; i(e[r], s) < 0; ) r++;
      for (; i(e[l], s) > 0; ) l--;
    }
    i(e[n], s) === 0 ? Ye(e, n, l) : (l++, Ye(e, l, o)), l <= t && (n = l + 1), t <= l && (o = l - 1);
  }
}
function Ye(e, t, n) {
  const o = e[t];
  e[t] = e[n], e[n] = o;
}
function ki(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
class Ii {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const o = [];
    if (!ze(t, n)) return o;
    const i = this.toBBox, s = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const l = n.children[r], a = n.leaf ? i(l) : l;
        ze(t, a) && (n.leaf ? o.push(l) : ct(t, a) ? this._all(l, o) : s.push(l));
      }
      n = s.pop();
    }
    return o;
  }
  collides(t) {
    let n = this.data;
    if (!ze(t, n)) return !1;
    const o = [];
    for (; n; ) {
      for (let i = 0; i < n.children.length; i++) {
        const s = n.children[i], r = n.leaf ? this.toBBox(s) : s;
        if (ze(t, r)) {
          if (n.leaf || ct(t, r)) return !0;
          o.push(s);
        }
      }
      n = o.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let o = 0; o < t.length; o++)
        this.insert(t[o]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const o = this.data;
        this.data = n, n = o;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = ve([]), this;
  }
  remove(t, n) {
    if (!t) return this;
    let o = this.data;
    const i = this.toBBox(t), s = [], r = [];
    let l, a, c;
    for (; o || s.length; ) {
      if (o || (o = s.pop(), a = s[s.length - 1], l = r.pop(), c = !0), o.leaf) {
        const u = Bi(t, o.children, n);
        if (u !== -1)
          return o.children.splice(u, 1), s.push(o), this._condense(s), this;
      }
      !c && !o.leaf && ct(o, i) ? (s.push(o), r.push(l), l = 0, a = o, o = o.children[0]) : a ? (l++, o = a.children[l], c = !1) : o = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const o = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : o.push(...t.children), t = o.pop();
    return n;
  }
  _build(t, n, o, i) {
    const s = o - n + 1;
    let r = this._maxEntries, l;
    if (s <= r)
      return l = ve(t.slice(n, o + 1)), Te(l, this.toBBox), l;
    i || (i = Math.ceil(Math.log(s) / Math.log(r)), r = Math.ceil(s / Math.pow(r, i - 1))), l = ve([]), l.leaf = !1, l.height = i;
    const a = Math.ceil(s / r), c = a * Math.ceil(Math.sqrt(r));
    Ft(t, n, o, c, this.compareMinX);
    for (let u = n; u <= o; u += c) {
      const f = Math.min(u + c - 1, o);
      Ft(t, u, f, a, this.compareMinY);
      for (let h = u; h <= f; h += a) {
        const y = Math.min(h + a - 1, f);
        l.children.push(this._build(t, h, y, i - 1));
      }
    }
    return Te(l, this.toBBox), l;
  }
  _chooseSubtree(t, n, o, i) {
    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {
      let s = 1 / 0, r = 1 / 0, l;
      for (let a = 0; a < n.children.length; a++) {
        const c = n.children[a], u = at(c), f = Yi(t, c) - u;
        f < r ? (r = f, s = u < s ? u : s, l = c) : f === r && u < s && (s = u, l = c);
      }
      n = l || n.children[0];
    }
    return n;
  }
  _insert(t, n, o) {
    const i = o ? t : this.toBBox(t), s = [], r = this._chooseSubtree(i, this.data, n, s);
    for (r.children.push(t), Xe(r, i); n >= 0 && s[n].children.length > this._maxEntries; )
      this._split(s, n), n--;
    this._adjustParentBBoxes(i, s, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const o = t[n], i = o.children.length, s = this._minEntries;
    this._chooseSplitAxis(o, s, i);
    const r = this._chooseSplitIndex(o, s, i), l = ve(o.children.splice(r, o.children.length - r));
    l.height = o.height, l.leaf = o.leaf, Te(o, this.toBBox), Te(l, this.toBBox), n ? t[n - 1].children.push(l) : this._splitRoot(o, l);
  }
  _splitRoot(t, n) {
    this.data = ve([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, Te(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, o) {
    let i, s = 1 / 0, r = 1 / 0;
    for (let l = n; l <= o - n; l++) {
      const a = Ce(t, 0, l, this.toBBox), c = Ce(t, l, o, this.toBBox), u = Pi(a, c), f = at(a) + at(c);
      u < s ? (s = u, i = l, r = f < r ? f : r) : u === s && f < r && (r = f, i = l);
    }
    return i || o - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, o) {
    const i = t.leaf ? this.compareMinX : Oi, s = t.leaf ? this.compareMinY : Di, r = this._allDistMargin(t, n, o, i), l = this._allDistMargin(t, n, o, s);
    r < l && t.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, o, i) {
    t.children.sort(i);
    const s = this.toBBox, r = Ce(t, 0, n, s), l = Ce(t, o - n, o, s);
    let a = je(r) + je(l);
    for (let c = n; c < o - n; c++) {
      const u = t.children[c];
      Xe(r, t.leaf ? s(u) : u), a += je(r);
    }
    for (let c = o - n - 1; c >= n; c--) {
      const u = t.children[c];
      Xe(l, t.leaf ? s(u) : u), a += je(l);
    }
    return a;
  }
  _adjustParentBBoxes(t, n, o) {
    for (let i = o; i >= 0; i--)
      Xe(n[i], t);
  }
  _condense(t) {
    for (let n = t.length - 1, o; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (o = t[n - 1].children, o.splice(o.indexOf(t[n]), 1)) : this.clear() : Te(t[n], this.toBBox);
  }
}
function Bi(e, t, n) {
  if (!n) return t.indexOf(e);
  for (let o = 0; o < t.length; o++)
    if (n(e, t[o])) return o;
  return -1;
}
function Te(e, t) {
  Ce(e, 0, e.children.length, t, e);
}
function Ce(e, t, n, o, i) {
  i || (i = ve(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let s = t; s < n; s++) {
    const r = e.children[s];
    Xe(i, e.leaf ? o(r) : r);
  }
  return i;
}
function Xe(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function Oi(e, t) {
  return e.minX - t.minX;
}
function Di(e, t) {
  return e.minY - t.minY;
}
function at(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function je(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Yi(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function Pi(e, t) {
  const n = Math.max(e.minX, t.minX), o = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);
  return Math.max(0, i - n) * Math.max(0, s - o);
}
function ct(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function ze(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function ve(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Ft(e, t, n, o, i) {
  const s = [t, n];
  for (; s.length; ) {
    if (n = s.pop(), t = s.pop(), n - t <= o) continue;
    const r = t + Math.ceil((n - t) / o / 2) * o;
    dn(e, r, t, n, i), s.push(t, r, r, n);
  }
}
const Ci = () => {
  const e = new Ii(), t = /* @__PURE__ */ new Map(), n = () => [...t.values()], o = () => {
    e.clear(), t.clear();
  }, i = (f) => {
    if (!Fe(f)) return;
    const { minX: h, minY: y, maxX: g, maxY: m } = f.selector.geometry.bounds, A = { minX: h, minY: y, maxX: g, maxY: m, target: f };
    e.insert(A), t.set(f.annotation, A);
  }, s = (f) => {
    if (!Fe(f)) return;
    const h = t.get(f.annotation);
    h && e.remove(h), t.delete(f.annotation);
  };
  return {
    all: n,
    clear: o,
    getAt: (f, h) => {
      const g = e.search({
        minX: f,
        minY: h,
        maxX: f,
        maxY: h
      }).map((m) => m.target).filter((m) => m.selector.type === F.RECTANGLE || kn(m.selector, f, h));
      if (g.length > 0)
        return g.sort((m, A) => ht(m.selector) - ht(A.selector)), g[0];
    },
    getIntersecting: (f, h, y, g) => e.search({
      minX: f,
      minY: h,
      maxX: f + y,
      maxY: h + g
    }).map((m) => m.target),
    insert: i,
    remove: s,
    set: (f, h = !0) => {
      h && o();
      const y = f.reduce((g, m) => {
        if (Fe(m)) {
          const { minX: A, minY: p, maxX: _, maxY: w } = m.selector.geometry.bounds;
          return [...g, { minX: A, minY: p, maxX: _, maxY: w, target: m }];
        } else
          return g;
      }, []);
      y.forEach((g) => t.set(g.target.annotation, g)), e.load(y);
    },
    size: () => e.all().length,
    update: (f, h) => {
      s(f), i(h);
    }
  };
}, Xi = (e) => {
  const t = io(), n = Ci(), o = Kn(t, e.userSelectAction, e.adapter), i = Fn(t), s = co();
  return t.observe(({ changes: a }) => {
    n.set((a.created || []).map((c) => c.target), !1), (a.deleted || []).forEach((c) => n.remove(c.target)), (a.updated || []).forEach(({ oldValue: c, newValue: u }) => n.update(c.target, u.target));
  }), {
    store: {
      ...t,
      getAt: (a, c) => {
        const u = n.getAt(a, c);
        return u ? t.getAnnotation(u.annotation) : void 0;
      },
      getIntersecting: (a, c, u, f) => n.getIntersecting(a, c, u, f).map((h) => t.getAnnotation(h.annotation))
    },
    selection: o,
    hover: i,
    viewport: s
  };
}, Ui = (e) => {
  const t = Xi(e);
  return {
    ...t,
    store: so(t.store)
  };
}, Ri = (e) => {
  let t, n;
  if (e.nodeName === "CANVAS")
    t = e, n = t.getContext("2d", { willReadFrequently: !0 });
  else {
    const i = e;
    t = document.createElement("canvas"), t.width = i.width, t.height = i.height, n = t.getContext("2d", { willReadFrequently: !0 }), n.drawImage(i, 0, 0, i.width, i.height);
  }
  let o = 0;
  for (let i = 1; i < 10; i++)
    for (let s = 1; s < 10; s++) {
      const r = Math.round(s * t.width / 10), l = Math.round(i * t.height / 10), a = n.getImageData(r, l, 1, 1).data, c = (0.299 * a[0] + 0.587 * a[1] + 0.114 * a[2]) / 255;
      o += c;
    }
  return o / 81;
}, Ni = (e) => {
  const t = Ri(e), n = t > 0.6 ? "dark" : "light";
  return console.log(`[Annotorious] Image brightness: ${t.toFixed(1)}. Setting ${n} theme.`), n;
}, Kt = (e, t, n) => t.setAttribute("data-theme", n === "auto" ? Ni(e) : n), Vi = (e, t) => ({
  ...e,
  drawingEnabled: e.drawingEnabled === void 0 ? t.drawingEnabled : e.drawingEnabled,
  drawingMode: e.drawingMode || t.drawingMode,
  userSelectAction: e.userSelectAction || t.userSelectAction,
  theme: e.theme || t.theme
}), Wt = typeof navigator > "u" ? !1 : navigator.userAgent.indexOf("Mac OS X") !== -1, Gi = (e, t) => {
  const n = t || document, o = (r) => {
    const l = r;
    l.key === "z" && l.ctrlKey ? e.undo() : l.key === "y" && l.ctrlKey && e.redo();
  }, i = (r) => {
    const l = r;
    l.key === "z" && l.metaKey && (l.shiftKey ? e.redo() : e.undo());
  }, s = () => {
    Wt ? n.removeEventListener("keydown", i) : n.removeEventListener("keydown", o);
  };
  return Wt ? n.addEventListener("keydown", i) : n.addEventListener("keydown", o), {
    destroy: s
  };
}, Ji = (e, t = {}) => {
  if (!e)
    throw "Missing argument: image";
  const n = typeof e == "string" ? document.getElementById(e) : e, o = Vi(t, {
    drawingEnabled: !0,
    drawingMode: "drag",
    userSelectAction: nn.EDIT,
    theme: "light"
  }), i = Ui(o), { selection: s, store: r } = i, l = ao(r, o.initialHistory), a = fo(
    i,
    l,
    o.adapter,
    o.autoSave
  ), c = document.createElement("DIV");
  c.style.position = "relative", c.style.display = "inline-block", n.style.display = "block", n.parentNode.insertBefore(c, n), c.appendChild(n);
  const u = Gi(l);
  let f = wo();
  Kt(n, c, o.theme);
  const h = new Li({
    target: c,
    props: {
      drawingEnabled: !!o.drawingEnabled,
      image: n,
      preferredDrawingMode: o.drawingMode,
      state: i,
      style: o.style,
      user: f
    }
  });
  h.$on("click", (b) => {
    const { originalEvent: T, annotation: Y } = b.detail;
    Y ? s.userSelect(Y.id, T) : s.isEmpty() || s.clear();
  });
  const y = ho(i, l, o.adapter), g = () => h.cancelDrawing(), m = () => {
    h.$destroy(), c.parentNode.insertBefore(n, c), c.parentNode.removeChild(c), u.destroy(), l.destroy();
  }, A = () => h.getDrawingTool(), p = () => f, _ = () => h.isDrawingEnabled(), w = (b, T, Y) => si(b, T, Y), E = (b, T) => zo(b, T), k = (b) => {
    if (!fn(b))
      throw `No drawing tool named ${b}`;
    h.$set({ toolName: b });
  }, X = (b) => h.$set({ drawingEnabled: b }), R = (b) => {
    console.warn("Filter not implemented yet");
  }, V = (b) => h.$set({ style: b }), Z = (b) => Kt(n, c, b), S = (b) => {
    f = b, h.$set({ user: b });
  }, v = (b) => (
    // @ts-ignore
    h.$set({ visible: b })
  );
  return {
    ...y,
    cancelDrawing: g,
    destroy: m,
    getDrawingTool: A,
    getUser: p,
    isDrawingEnabled: _,
    listDrawingTools: cn,
    on: a.on,
    off: a.off,
    registerDrawingTool: w,
    registerShapeEditor: E,
    setDrawingEnabled: X,
    setDrawingTool: k,
    setFilter: R,
    setStyle: V,
    setTheme: Z,
    setUser: S,
    setVisible: v,
    element: c,
    state: i
  };
};
export {
  an as Editor,
  qo as EditorMount,
  Pe as Handle,
  qi as IdentityTransform,
  Io as PolygonEditor,
  Go as RectangleEditor,
  On as RectangleUtil,
  $o as RubberbandRectangle,
  Li as SVGAnnotationLayer,
  F as ShapeType,
  Qo as ToolMount,
  nn as UserSelectAction,
  Wi as W3CImageFormat,
  wi as addEventListeners,
  qe as boundsFromPoints,
  Fi as chainStyles,
  ht as computeArea,
  Hi as computeStyle,
  zi as createBody,
  Ji as createImageAnnotator,
  Xi as createImageAnnotatorState,
  yi as createSVGTransform,
  Ui as createSvelteImageAnnotatorState,
  Ki as defaultColorProvider,
  Ni as detectTheme,
  st as distance,
  Do as enableResponsive,
  Vi as fillDefaults,
  jo as getEditor,
  un as getSVGPoint,
  fn as getTool,
  Gi as initKeyboardCommands,
  kn as intersects,
  Je as isImageAnnotation,
  Fe as isImageAnnotationTarget,
  Wt as isMac,
  Yo as isTouch,
  cn as listDrawingTools,
  Dn as parseFragmentSelector,
  Rn as parseSVGSelector,
  To as parseW3CImageAnnotation,
  zo as registerEditor,
  pt as registerShapeUtil,
  si as registerTool,
  Ri as sampleBrightness,
  Yn as serializeFragmentSelector,
  Nn as serializeSVGSelector,
  Mo as serializeW3CImageAnnotation,
  Kt as setTheme
};
//# sourceMappingURL=annotorious.es.js.map
